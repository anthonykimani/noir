{
    "transpiled": true,
    "noir_version": "0.36.0+b0cbf84eaf69f77628939184c9b869cfb3e15846-x8664",
    "name": "Counter",
    "functions": [
        {
            "name": "increment",
            "is_unconstrained": false,
            "custom_attributes": [
                "private"
            ],
            "abi": {
                "error_types": {},
                "parameters": [
                    {
                        "name": "inputs",
                        "type": {
                            "fields": [
                                {
                                    "name": "call_context",
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "msg_sender",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                }
                                            },
                                            {
                                                "name": "contract_address",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                }
                                            },
                                            {
                                                "name": "function_selector",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                                }
                                            },
                                            {
                                                "name": "is_static_call",
                                                "type": {
                                                    "kind": "boolean"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::call_context::CallContext"
                                    }
                                },
                                {
                                    "name": "historical_header",
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "last_archive",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "root",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "next_available_leaf_index",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                }
                                            },
                                            {
                                                "name": "content_commitment",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "num_txs",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "txs_effects_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "in_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "out_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                                                }
                                            },
                                            {
                                                "name": "state",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "l1_to_l2_message_tree",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "root",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "next_available_leaf_index",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                            }
                                                        },
                                                        {
                                                            "name": "partial",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "note_hash_tree",
                                                                        "type": {
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ],
                                                                            "kind": "struct",
                                                                            "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "nullifier_tree",
                                                                        "type": {
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ],
                                                                            "kind": "struct",
                                                                            "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "public_data_tree",
                                                                        "type": {
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ],
                                                                            "kind": "struct",
                                                                            "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::state_reference::StateReference"
                                                }
                                            },
                                            {
                                                "name": "global_variables",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "chain_id",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "version",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "block_number",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "slot_number",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "timestamp",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 64
                                                            }
                                                        },
                                                        {
                                                            "name": "coinbase",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                                            }
                                                        },
                                                        {
                                                            "name": "fee_recipient",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                            }
                                                        },
                                                        {
                                                            "name": "gas_fees",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                                                }
                                            },
                                            {
                                                "name": "total_fees",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::header::Header"
                                    }
                                },
                                {
                                    "name": "tx_context",
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "chain_id",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "version",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "gas_settings",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "gas_limits",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::abis::gas::Gas"
                                                            }
                                                        },
                                                        {
                                                            "name": "teardown_gas_limits",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::abis::gas::Gas"
                                                            }
                                                        },
                                                        {
                                                            "name": "max_fees_per_gas",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                                                            }
                                                        },
                                                        {
                                                            "name": "inclusion_fee",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                                    }
                                },
                                {
                                    "name": "start_side_effect_counter",
                                    "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "owner",
                        "type": {
                            "fields": [
                                {
                                    "name": "inner",
                                    "type": {
                                        "kind": "field"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "outgoing_viewer",
                        "type": {
                            "fields": [
                                {
                                    "name": "inner",
                                    "type": {
                                        "kind": "field"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": {
                    "abi_type": {
                        "fields": [
                            {
                                "name": "call_context",
                                "type": {
                                    "fields": [
                                        {
                                            "name": "msg_sender",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                            }
                                        },
                                        {
                                            "name": "contract_address",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                            }
                                        },
                                        {
                                            "name": "function_selector",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                            }
                                        },
                                        {
                                            "name": "is_static_call",
                                            "type": {
                                                "kind": "boolean"
                                            }
                                        }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                                }
                            },
                            {
                                "name": "args_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "returns_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "min_revertible_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "is_fee_payer",
                                "type": {
                                    "kind": "boolean"
                                }
                            },
                            {
                                "name": "max_block_number",
                                "type": {
                                    "fields": [
                                        {
                                            "name": "_opt",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "_is_some",
                                                        "type": {
                                                            "kind": "boolean"
                                                        }
                                                    },
                                                    {
                                                        "name": "_value",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "std::option::Option"
                                            }
                                        }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                                }
                            },
                            {
                                "name": "note_hash_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                                    }
                                }
                            },
                            {
                                "name": "nullifier_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                                    }
                                }
                            },
                            {
                                "name": "key_validation_requests_and_generators",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "request",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "pk_m",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "x",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "y",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "is_infinite",
                                                                        "type": {
                                                                            "kind": "boolean"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                                            }
                                                        },
                                                        {
                                                            "name": "sk_app",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                                                }
                                            },
                                            {
                                                "name": "sk_app_generator",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                                    }
                                }
                            },
                            {
                                "name": "note_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                                    }
                                }
                            },
                            {
                                "name": "nullifiers",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "note_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                                    }
                                }
                            },
                            {
                                "name": "private_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 4,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "call_context",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "msg_sender",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                            }
                                                        },
                                                        {
                                                            "name": "contract_address",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                            }
                                                        },
                                                        {
                                                            "name": "function_selector",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                                            }
                                                        },
                                                        {
                                                            "name": "is_static_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                                                }
                                            },
                                            {
                                                "name": "args_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "returns_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "start_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "end_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                                    }
                                }
                            },
                            {
                                "name": "public_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "call_context",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "msg_sender",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                            }
                                                        },
                                                        {
                                                            "name": "contract_address",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                            }
                                                        },
                                                        {
                                                            "name": "function_selector",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                                            }
                                                        },
                                                        {
                                                            "name": "is_static_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                                                }
                                            },
                                            {
                                                "name": "args_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                                    }
                                }
                            },
                            {
                                "name": "public_teardown_call_request",
                                "type": {
                                    "fields": [
                                        {
                                            "name": "call_context",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "msg_sender",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                        }
                                                    },
                                                    {
                                                        "name": "contract_address",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                        }
                                                    },
                                                    {
                                                        "name": "function_selector",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                                        }
                                                    },
                                                    {
                                                        "name": "is_static_call",
                                                        "type": {
                                                            "kind": "boolean"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                                            }
                                        },
                                        {
                                            "name": "args_hash",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "counter",
                                            "type": {
                                                "kind": "integer",
                                                "sign": "unsigned",
                                                "width": 32
                                            }
                                        }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                                }
                            },
                            {
                                "name": "l2_to_l1_msgs",
                                "type": {
                                    "kind": "array",
                                    "length": 2,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "recipient",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                                }
                                            },
                                            {
                                                "name": "content",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                                    }
                                }
                            },
                            {
                                "name": "start_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "end_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "note_encrypted_logs_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "length",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "note_hash_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::log_hash::NoteLogHash"
                                    }
                                }
                            },
                            {
                                "name": "encrypted_logs_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 4,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "length",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "randomness",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::log_hash::EncryptedLogHash"
                                    }
                                }
                            },
                            {
                                "name": "unencrypted_logs_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 4,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "length",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::log_hash::LogHash"
                                    }
                                }
                            },
                            {
                                "name": "historical_header",
                                "type": {
                                    "fields": [
                                        {
                                            "name": "last_archive",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "root",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "next_available_leaf_index",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                            }
                                        },
                                        {
                                            "name": "content_commitment",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "num_txs",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "txs_effects_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "in_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "out_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                                            }
                                        },
                                        {
                                            "name": "state",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "l1_to_l2_message_tree",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "root",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "next_available_leaf_index",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                        }
                                                    },
                                                    {
                                                        "name": "partial",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "note_hash_tree",
                                                                    "type": {
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ],
                                                                        "kind": "struct",
                                                                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "nullifier_tree",
                                                                    "type": {
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ],
                                                                        "kind": "struct",
                                                                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "public_data_tree",
                                                                    "type": {
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ],
                                                                        "kind": "struct",
                                                                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::state_reference::StateReference"
                                            }
                                        },
                                        {
                                            "name": "global_variables",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "chain_id",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "version",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "block_number",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "slot_number",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "timestamp",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 64
                                                        }
                                                    },
                                                    {
                                                        "name": "coinbase",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                                        }
                                                    },
                                                    {
                                                        "name": "fee_recipient",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                        }
                                                    },
                                                    {
                                                        "name": "gas_fees",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                                            }
                                        },
                                        {
                                            "name": "total_fees",
                                            "type": {
                                                "kind": "field"
                                            }
                                        }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::header::Header"
                                }
                            },
                            {
                                "name": "tx_context",
                                "type": {
                                    "fields": [
                                        {
                                            "name": "chain_id",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "version",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "gas_settings",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "gas_limits",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::abis::gas::Gas"
                                                        }
                                                    },
                                                    {
                                                        "name": "teardown_gas_limits",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::abis::gas::Gas"
                                                        }
                                                    },
                                                    {
                                                        "name": "max_fees_per_gas",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                                                        }
                                                    },
                                                    {
                                                        "name": "inclusion_fee",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                                            }
                                        }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                                }
                            }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
                    },
                    "visibility": "databus"
                }
            },
            "bytecode": "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",
            "debug_symbols": "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5t5nsfv0ydLu0yfLIcs2Wdp9+mRp9+mTpd2nT5Z2nz5Z2n3aZLnaffpkaffpk6Xdp0+Wdp8+WQ5ZtsnS7tPmzGu1+/TJ0u7TJ0u7T58s7T5t7n3Odp8+Wdp9+mRp9+mTpd2nT5ZDlm2ytPv0ydLu0ydLu0+fLO0+fbK0+7TJcth9+mRp9+mTpd2nT5Z2nzZnXmPIsk2Wdp8+Wdp9+mRp9+lz72P36ZOl3adNlpvdp0+Wdp8+Wdp9+mRp9+mT5ZBlmyztPn2ytPv0ydLu0ydLu0+fLO0+bbK82H36ZGn3aXPmdbH79MnS7tMnyyHLNlnaffrc+9h9+mRp9+mTpd2nT5Z2nzZZXu0+fbK0+/TJ0u7TJ0u7T58shyzbZGn36ZOl3adPlnafPlnaffpkafdpc+a12336ZGn36ZOl3adPlnafNvc++5BlmyztPn2ytPv0ydLu0ydLu0+fLO0+bbK82X36ZGn36ZOl3adPlnafPlkOWbbJ0u7TJ0u7T58s7T5tzrxudp8+Wdp9umS5nuw+fbK0+3S591lPdp8+Wdp9+mQ5ZNkmS7tPnyztPn2ytPv0ydLu0ydLu0+bLBe7T58s7T59srT79MnS7tMnyyHLNlnafdqceS12nz5Z2n36ZGn36ZOl3afNvc9q9+mTpd2nT5Z2nz5Z2n36ZDlk2SZLu0+fLO0+fbK0+/TJ0u7TJ0u7T5ssz3afPlnaffpkaffpk6Xdp82Z13nIsk2Wdp8+Wdp9+mRp9+lz72P36ZOl3adNlsPu0ydLu0+fLO0+fbK0+/TJcsiyTZZ2nz5Z2n36ZGn36ZOl3adPlnafNlludp8+Wdp92px5bXafPlnaffpkOWTZJku7T597H7tPnyztPn2ytPv0ydLu0ybLi92nT5Z2nz5Z2n36ZGn36ZPlkGWbLO0+fbK0+/TJ0u7TJ0u7T58s7T5tzryudp8+Wdp9+mRp9+mTpd2nzb3PdciyTZZ2nz5Z2n36ZGn36ZOl3adPlnafNlnudp8+Wdp9+mRp9+mTpd2nT5ZDlm2ytPv0ydLu0ydLu0+bM6/d7tMnS7tPmyxvdp8+Wdp92tz73Ow+fbK0+/TJcsiyTZZ2nz5Z2n36ZGn36ZOl3adPlnafLlmeT3afPlnaffpkaffpk6Xdp0+WQ5ZtsrT7dDnzOp/sPn2ytPv0ydLu0ydLu0+be5/F7tMnS7tPnyztPn2ytPv0yXLIsk2Wdp8+Wdp9+mRp9+mTpd2nT5Z2nzZZrnafPlnaffpkaffpk6Xdp82Z1zpk2SZLu0+fLO0+fbK0+/S597H79MnS7tMmy7Pdp0+Wdp8+Wdp9+mRp9+mT5ZBlmyztPn2ytPv0ydLu0ydLu0+fLO0+bbIcdp8+Wdp92px5DbtPnyztPn2yHLJsk6Xdp8+9j92nT5Z2nz5Z2n36ZGn3aZPlZvfpk6Xdp0+Wdp8+Wdp9+mQ5ZNkmS7tPnyztPn2ytPv0ydLu0ydLu0+bM6+L3adPlnafPlnaffpkafdpc+9zGbJsk6Xdp0+Wdp8+Wdp9+mRp9+mTpd2nTZZXu0+fLO0+fbK0+/TJ0u7TJ8shyzZZ2n36ZGn36ZOl3afNmdfV7tMnS7tPmyx3u0+fLO0+be59drtPnyztPn2yHLJsk6Xdp0+Wdp8+Wdp9+mRp9+mTpd2nTZY3u0+fLO0+fbK0+/TJ0u7TJ8shyzZZ2n3anHnd7D59srT79MnS7tMnS7tPl3ufcbL79MnS7tMnS7tPnyztPn2yHLJsk6Xdp0+Wdp8+Wdp9+mRp9+mTpd2nTZaL3adPlnafPlnaffpkaffpcuY1liHLNlnaffpkaffpk6Xdp8+9j92nT5Z2nzZZrnafPlnaffpkaffpk6Xdp0+WQ5ZtsrT79MnS7tMnS7tPnyztPn2ytPu0yfJs9+mTpd2nzZnX2e7TJ0u7T58shyzbZGn36XPvY/fpk6Xdp0+Wdp8+Wdp92mQ57D59srT79MnS7tMnS7tPnyyHLNtkaffpk6Xdp0+Wdp8+Wdp9+mRp92lz5rXZffpkaffpk6Xdp0+Wdp829z7bkGWbLO0+fbK0+/TJ0u7TJ0u7T58s7T5tsrzYffpkaffpk6Xdp0+Wdp8+WQ5ZtsnS7tMnS7tPnyztPm3OvC52nz5Z2n3aZHm1+/TJ0u7T5t7navfpk6Xdp0+WQ5ZtsrT79MnS7tMnS7tPnyztPn2ytPu0yXK3+/TJ0u7TJ0u7T58s7T59shyybJOl3afNmddu9+mTpd2nT5Z2nz7XS7tPmyxvdp8+Wdp9+mRp9+mTpd2nT5ZDll2c5Gb36ZOl3adPlnafPtdLu0+fLO0+XbLcTnafPlnaffpkaffpk6Xdp4uTbKchyzZZ2n36ZGn36ZOl3afPvY/dp0+Wdp82WS52nz5Z2n36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aZ/yyGmf8shpn/LIjcjVkdM+5ZHTPuWR0z7lkdM+5ZHTPtWRb7RPeeS0T3nktE955LRPtbzdjMjVkdM+5ZHTPuWR0z7lt0/apzxy2qc6cqN9yiOnfcojp33KI6d9yiM3IldHTvuUR077lEdO+5RHTvuUR077VEdeaZ/yyGmfanlbaZ/yyGmf8siNyNWR0z7lt0/apzxy2qc8ctqnPHLapzryRvuUR077lEdO+5RHTvuUR25Ero6c9imPnPYpj5z2KY+c9imPnPaplred9imPnPYpj5z2KY+c9qm+fXYjcnXktE955LRPeeS0T3nktE955LRPdeSD9imPnPYpj5z2KY+c9imP3IhcHTntUx457VMeOe1TLW8H7VMeOe1THflO+5RHTvtU3z532qc8ctqnPHIjcnXktE955LRPeeS0T3nktE955LRPceQfoRO5OnLapzxy2qc8ctqnPHIjcnXktE+xvF0X2qc8ctqnPHLapzxy2qf69rnSPuWR0z7lkdM+5ZHTPuWRG5GrI6d9yiOnfcojp33KI6d9yiOnfaojL7RPeeS0T3nktE955LRPtbwtRuTqyGmf8shpn/LIaZ/y2yftUx457VMd+Ub7lEdO+5RHTvuUR077lEduRK6OnPYpj5z2KY+c9imPnPYpj5z2qY7caJ/yyGmfanlrtE955LRPeeRG5OrIaZ/y2yftUx457VMeOe1THjntUx15pX3KI6d9yiOnfcojp33KIzciV0dO+5RHTvuUR077lEdO+5RHTvtUy9tG+5RHTvuUR077lEdO+1TfPpsRuTpy2qc8ctqnPHLapzxy2qc8ctqnOvJO+5RHTvuUR077lEdO+5RHbkSujpz2KY+c9imPnPaplred9imPnPapjnzQPuWR0z7Vt89B+5RHTvuUR25Ero6c9imPnPYpj5z2KY+c9imPnPapjnynfcojp33KI6d9yiOnfcojNyJXR077VMvbnfYpj5z2KY+c9imPnPYpvn2WhfYpj5z2KY+c9imPnPYpj9yIXB057VMeOe1THjntUx457VMeOe1THflK+5RHTvuUR077lEdO+xTL27Iakasjp33KI6d9yiOnfcpvn7RPeeS0T3XkhfYpj5z2KY+c9imPnPYpj9yIXB057VMeOe1THjntUx457VMeOe1THflG+5RHTvtUy9uN9imPnPYpj9yIXB057VN++6R9yiOnfcojp33KI6d9qiM32qc8ctqnPHLapzxy2qc8ciNydeS0T3nktE955LRPeeS0T3nktE+1vK20T3nktE955LRPeeS0T/XtsxqRqyOnfcojp33KI6d9yiOnfcojp32qI2+0T3nktE955LRPeeS0T3nkRuTqyGmf8shpn/LIaZ9qedton/LIaZ/qyDvtUx457VN9++y0T3nktE955Ebk6shpn/LIaZ/yyGmf8shpn/LIaZ/qyAftUx457VMeOe1THjntUx65Ebk6ctqnWt4O2qc8ctqnPHLapzxy2qf69rnTPuWR0z7lkdM+5ZHTPuWRG5GrI6d9yiOnfcojp33KI6d9yiOnfYoj3xbapzxy2qc8ctqnPHLap1jebosRuTpy2qc8ctqnPHLap/z2SfuUR077VEe+0j7lkdM+5ZHTPuWR0z7lkRuRqyOnfcojp33KI6d9yiOnfcojp32qIy+0T3nktE+1vC20T3nktE955Ebk6shpn/LbJ+1THjntUx457VMeOe1THflG+5RHTvuUR077lEdO+5RHbkSujpz2KY+c9imPnPYpj5z2KY+c9qmWt0b7lEdO+5RHTvuUR077VN8+zYhcHTntUx457VMeOe1THjntUx457VMdeaV9yiOnfcojp33KI6d9yiM3IldHTvuUR077lEdO+1TL20r7lEdO+1RH3mif8shpn+rbZ6N9yiOnfcojNyJXR077lEdO+5RHTvuUR077lEdO+1RH3mmf8shpn/LIaZ/yyGmf8siNyNWR0z7V8rbTPuWR0z7lkdM+5ZHTPtW3z0H7lEdO+5RHTvuUR077lEduRK6OnPYpj5z2KY+c9imPnPYpj5z2qY58p33KI6d9yiOnfcojp32q5e1uRK6OnPYpj5z2KY+c9im/fdI+5ZHTPsWR20L7lEdO+5RHTvuUR077lEduRK6OnPYpj5z2KY+c9imPnPYpj5z2qY58pX3KI6d9iuWtrbRPeeS0T3nkRuTqyGmf8tsn7VMeOe1THjntUx457VMdeaF9yiOnfcojp33KI6d9yiM3IldHTvuUR077lEdO+5RHTvuUR077VMvbjfYpj5z2KY+c9imPnPapvn1uRuTqyGmf8shpn/LIaZ/yyGmf8shpn+rIjfYpj5z2KY+c9imPnPYpj9yIXB057VMeOe1THjntUy1vjfYpj5z2qY680j7l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",
            "brillig_names": [
                "debug_log_oracle_wrapper",
                "get_public_keys_and_partial_address",
                "decompose_hint",
                "lte_hint",
                "random",
                "notify_created_note_oracle_wrapper",
                "get_key_validation_request",
                "field_less_than",
                "build_msg_block",
                "attach_len_to_msg_block",
                "build_msg_block",
                "emit_encrypted_note_log_oracle_wrapper",
                "directive_invert",
                "directive_integer_quotient"
            ]
        },
        {
            "name": "compute_note_hash_and_optionally_a_nullifier",
            "is_unconstrained": true,
            "custom_attributes": [],
            "abi": {
                "error_types": {
                    "3469988399892582431": {
                        "error_kind": "fmtstring",
                        "item_types": [],
                        "length": 20
                    }
                },
                "parameters": [
                    {
                        "name": "contract_address",
                        "type": {
                            "fields": [
                                {
                                    "name": "inner",
                                    "type": {
                                        "kind": "field"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "nonce",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "storage_slot",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "note_type_id",
                        "type": {
                            "kind": "field"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "compute_nullifier",
                        "type": {
                            "kind": "boolean"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "serialized_note",
                        "type": {
                            "kind": "array",
                            "length": 3,
                            "type": {
                                "kind": "field"
                            }
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": {
                    "abi_type": {
                        "kind": "array",
                        "length": 4,
                        "type": {
                            "kind": "field"
                        }
                    },
                    "visibility": "public"
                }
            },
            "bytecode": "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",
            "debug_symbols": "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",
            "brillig_names": [
                "compute_note_hash_and_optionally_a_nullifier"
            ]
        },
        {
            "name": "initialize",
            "is_unconstrained": false,
            "custom_attributes": [
                "initializer",
                "private"
            ],
            "abi": {
                "error_types": {},
                "parameters": [
                    {
                        "name": "inputs",
                        "type": {
                            "fields": [
                                {
                                    "name": "call_context",
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "msg_sender",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                }
                                            },
                                            {
                                                "name": "contract_address",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                }
                                            },
                                            {
                                                "name": "function_selector",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                                }
                                            },
                                            {
                                                "name": "is_static_call",
                                                "type": {
                                                    "kind": "boolean"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::call_context::CallContext"
                                    }
                                },
                                {
                                    "name": "historical_header",
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "last_archive",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "root",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "next_available_leaf_index",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 32
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                }
                                            },
                                            {
                                                "name": "content_commitment",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "num_txs",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "txs_effects_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "in_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "out_hash",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                                                }
                                            },
                                            {
                                                "name": "state",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "l1_to_l2_message_tree",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "root",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "next_available_leaf_index",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                            }
                                                        },
                                                        {
                                                            "name": "partial",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "note_hash_tree",
                                                                        "type": {
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ],
                                                                            "kind": "struct",
                                                                            "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "nullifier_tree",
                                                                        "type": {
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ],
                                                                            "kind": "struct",
                                                                            "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "public_data_tree",
                                                                        "type": {
                                                                            "fields": [
                                                                                {
                                                                                    "name": "root",
                                                                                    "type": {
                                                                                        "kind": "field"
                                                                                    }
                                                                                },
                                                                                {
                                                                                    "name": "next_available_leaf_index",
                                                                                    "type": {
                                                                                        "kind": "integer",
                                                                                        "sign": "unsigned",
                                                                                        "width": 32
                                                                                    }
                                                                                }
                                                                            ],
                                                                            "kind": "struct",
                                                                            "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::state_reference::StateReference"
                                                }
                                            },
                                            {
                                                "name": "global_variables",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "chain_id",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "version",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "block_number",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "slot_number",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        },
                                                        {
                                                            "name": "timestamp",
                                                            "type": {
                                                                "kind": "integer",
                                                                "sign": "unsigned",
                                                                "width": 64
                                                            }
                                                        },
                                                        {
                                                            "name": "coinbase",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                                            }
                                                        },
                                                        {
                                                            "name": "fee_recipient",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                            }
                                                        },
                                                        {
                                                            "name": "gas_fees",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                                                }
                                            },
                                            {
                                                "name": "total_fees",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::header::Header"
                                    }
                                },
                                {
                                    "name": "tx_context",
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "chain_id",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "version",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "gas_settings",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "gas_limits",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::abis::gas::Gas"
                                                            }
                                                        },
                                                        {
                                                            "name": "teardown_gas_limits",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "da_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "l2_gas",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::abis::gas::Gas"
                                                            }
                                                        },
                                                        {
                                                            "name": "max_fees_per_gas",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "fee_per_da_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "fee_per_l2_gas",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                                                            }
                                                        },
                                                        {
                                                            "name": "inclusion_fee",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                                    }
                                },
                                {
                                    "name": "start_side_effect_counter",
                                    "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "headstart",
                        "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 64
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "owner",
                        "type": {
                            "fields": [
                                {
                                    "name": "inner",
                                    "type": {
                                        "kind": "field"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        },
                        "visibility": "private"
                    },
                    {
                        "name": "outgoing_viewer",
                        "type": {
                            "fields": [
                                {
                                    "name": "inner",
                                    "type": {
                                        "kind": "field"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": {
                    "abi_type": {
                        "fields": [
                            {
                                "name": "call_context",
                                "type": {
                                    "fields": [
                                        {
                                            "name": "msg_sender",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                            }
                                        },
                                        {
                                            "name": "contract_address",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                            }
                                        },
                                        {
                                            "name": "function_selector",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "inner",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                            }
                                        },
                                        {
                                            "name": "is_static_call",
                                            "type": {
                                                "kind": "boolean"
                                            }
                                        }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                                }
                            },
                            {
                                "name": "args_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "returns_hash",
                                "type": {
                                    "kind": "field"
                                }
                            },
                            {
                                "name": "min_revertible_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "is_fee_payer",
                                "type": {
                                    "kind": "boolean"
                                }
                            },
                            {
                                "name": "max_block_number",
                                "type": {
                                    "fields": [
                                        {
                                            "name": "_opt",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "_is_some",
                                                        "type": {
                                                            "kind": "boolean"
                                                        }
                                                    },
                                                    {
                                                        "name": "_value",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "std::option::Option"
                                            }
                                        }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                                }
                            },
                            {
                                "name": "note_hash_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                                    }
                                }
                            },
                            {
                                "name": "nullifier_read_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                                    }
                                }
                            },
                            {
                                "name": "key_validation_requests_and_generators",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "request",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "pk_m",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "x",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "y",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    },
                                                                    {
                                                                        "name": "is_infinite",
                                                                        "type": {
                                                                            "kind": "boolean"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                                            }
                                                        },
                                                        {
                                                            "name": "sk_app",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                                                }
                                            },
                                            {
                                                "name": "sk_app_generator",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                                    }
                                }
                            },
                            {
                                "name": "note_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                                    }
                                }
                            },
                            {
                                "name": "nullifiers",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "note_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                                    }
                                }
                            },
                            {
                                "name": "private_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 4,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "call_context",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "msg_sender",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                            }
                                                        },
                                                        {
                                                            "name": "contract_address",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                            }
                                                        },
                                                        {
                                                            "name": "function_selector",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                                            }
                                                        },
                                                        {
                                                            "name": "is_static_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                                                }
                                            },
                                            {
                                                "name": "args_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "returns_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "start_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "end_side_effect_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                                    }
                                }
                            },
                            {
                                "name": "public_call_requests",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "call_context",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "msg_sender",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                            }
                                                        },
                                                        {
                                                            "name": "contract_address",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "field"
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                            }
                                                        },
                                                        {
                                                            "name": "function_selector",
                                                            "type": {
                                                                "fields": [
                                                                    {
                                                                        "name": "inner",
                                                                        "type": {
                                                                            "kind": "integer",
                                                                            "sign": "unsigned",
                                                                            "width": 32
                                                                        }
                                                                    }
                                                                ],
                                                                "kind": "struct",
                                                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                                            }
                                                        },
                                                        {
                                                            "name": "is_static_call",
                                                            "type": {
                                                                "kind": "boolean"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                                                }
                                            },
                                            {
                                                "name": "args_hash",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                                    }
                                }
                            },
                            {
                                "name": "public_teardown_call_request",
                                "type": {
                                    "fields": [
                                        {
                                            "name": "call_context",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "msg_sender",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                        }
                                                    },
                                                    {
                                                        "name": "contract_address",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                        }
                                                    },
                                                    {
                                                        "name": "function_selector",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                                        }
                                                    },
                                                    {
                                                        "name": "is_static_call",
                                                        "type": {
                                                            "kind": "boolean"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                                            }
                                        },
                                        {
                                            "name": "args_hash",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "counter",
                                            "type": {
                                                "kind": "integer",
                                                "sign": "unsigned",
                                                "width": 32
                                            }
                                        }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                                }
                            },
                            {
                                "name": "l2_to_l1_msgs",
                                "type": {
                                    "kind": "array",
                                    "length": 2,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "recipient",
                                                "type": {
                                                    "fields": [
                                                        {
                                                            "name": "inner",
                                                            "type": {
                                                                "kind": "field"
                                                            }
                                                        }
                                                    ],
                                                    "kind": "struct",
                                                    "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                                }
                                            },
                                            {
                                                "name": "content",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                                    }
                                }
                            },
                            {
                                "name": "start_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "end_side_effect_counter",
                                "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                }
                            },
                            {
                                "name": "note_encrypted_logs_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 16,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "length",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "note_hash_counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::log_hash::NoteLogHash"
                                    }
                                }
                            },
                            {
                                "name": "encrypted_logs_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 4,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "length",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "randomness",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::log_hash::EncryptedLogHash"
                                    }
                                }
                            },
                            {
                                "name": "unencrypted_logs_hashes",
                                "type": {
                                    "kind": "array",
                                    "length": 4,
                                    "type": {
                                        "fields": [
                                            {
                                                "name": "value",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            },
                                            {
                                                "name": "counter",
                                                "type": {
                                                    "kind": "integer",
                                                    "sign": "unsigned",
                                                    "width": 32
                                                }
                                            },
                                            {
                                                "name": "length",
                                                "type": {
                                                    "kind": "field"
                                                }
                                            }
                                        ],
                                        "kind": "struct",
                                        "path": "aztec::protocol_types::abis::log_hash::LogHash"
                                    }
                                }
                            },
                            {
                                "name": "historical_header",
                                "type": {
                                    "fields": [
                                        {
                                            "name": "last_archive",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "root",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "next_available_leaf_index",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 32
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                            }
                                        },
                                        {
                                            "name": "content_commitment",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "num_txs",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "txs_effects_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "in_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "out_hash",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                                            }
                                        },
                                        {
                                            "name": "state",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "l1_to_l2_message_tree",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "root",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "next_available_leaf_index",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                        }
                                                    },
                                                    {
                                                        "name": "partial",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "note_hash_tree",
                                                                    "type": {
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ],
                                                                        "kind": "struct",
                                                                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "nullifier_tree",
                                                                    "type": {
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ],
                                                                        "kind": "struct",
                                                                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "public_data_tree",
                                                                    "type": {
                                                                        "fields": [
                                                                            {
                                                                                "name": "root",
                                                                                "type": {
                                                                                    "kind": "field"
                                                                                }
                                                                            },
                                                                            {
                                                                                "name": "next_available_leaf_index",
                                                                                "type": {
                                                                                    "kind": "integer",
                                                                                    "sign": "unsigned",
                                                                                    "width": 32
                                                                                }
                                                                            }
                                                                        ],
                                                                        "kind": "struct",
                                                                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::state_reference::StateReference"
                                            }
                                        },
                                        {
                                            "name": "global_variables",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "chain_id",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "version",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "block_number",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "slot_number",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    },
                                                    {
                                                        "name": "timestamp",
                                                        "type": {
                                                            "kind": "integer",
                                                            "sign": "unsigned",
                                                            "width": 64
                                                        }
                                                    },
                                                    {
                                                        "name": "coinbase",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                                        }
                                                    },
                                                    {
                                                        "name": "fee_recipient",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "inner",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                                        }
                                                    },
                                                    {
                                                        "name": "gas_fees",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                                            }
                                        },
                                        {
                                            "name": "total_fees",
                                            "type": {
                                                "kind": "field"
                                            }
                                        }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::header::Header"
                                }
                            },
                            {
                                "name": "tx_context",
                                "type": {
                                    "fields": [
                                        {
                                            "name": "chain_id",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "version",
                                            "type": {
                                                "kind": "field"
                                            }
                                        },
                                        {
                                            "name": "gas_settings",
                                            "type": {
                                                "fields": [
                                                    {
                                                        "name": "gas_limits",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::abis::gas::Gas"
                                                        }
                                                    },
                                                    {
                                                        "name": "teardown_gas_limits",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "da_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                },
                                                                {
                                                                    "name": "l2_gas",
                                                                    "type": {
                                                                        "kind": "integer",
                                                                        "sign": "unsigned",
                                                                        "width": 32
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::abis::gas::Gas"
                                                        }
                                                    },
                                                    {
                                                        "name": "max_fees_per_gas",
                                                        "type": {
                                                            "fields": [
                                                                {
                                                                    "name": "fee_per_da_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                },
                                                                {
                                                                    "name": "fee_per_l2_gas",
                                                                    "type": {
                                                                        "kind": "field"
                                                                    }
                                                                }
                                                            ],
                                                            "kind": "struct",
                                                            "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                                                        }
                                                    },
                                                    {
                                                        "name": "inclusion_fee",
                                                        "type": {
                                                            "kind": "field"
                                                        }
                                                    }
                                                ],
                                                "kind": "struct",
                                                "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                                            }
                                        }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                                }
                            }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
                    },
                    "visibility": "databus"
                }
            },
            "bytecode": "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",
            "debug_symbols": "7P3RkivZlp3pvUtd8wLuWO4A6lVkMhmlZsto1kbKROqKpnfvOCcT2JEVqEBlT+yBFRMfr5JkWBzEPwbg/o8VO/x//cv/9l/+n/+///f/47/+t//9v/+Pf/nX/9v/+pf/47//v/7z//yv//2/ffzf/te/LOOf/2//4//zn//bP/6v/+N//uf/7//8l39d9svhP/3Lf/lv/9vHf54Oh///f/qX//2//h//5V/+9fTxn1++eD1dtj+/eD0vp9sXL8t656uP47T/+dXHbVwefPWyHE6n6ytZDpdfL2W9+1qWsa7XLx9juX31cdz95uvl9r1P589f/H//T/+ybMj8O2R2ZP4dMqfJySzLuL36ZT0/InM+X7/7cjlsJTJnZP4dMpcymXFYr2TGYf/V4OV0/Mf/wnr47f8LSz3ddbsSXdfz/imv452vPo3rF5/Ov+gv6/bPV7OmX83y69Xsf3k1d77z4fZps47x62Uc1/0e9+V0475cfn3vdf/jJz2+zU863uYn3d7mJ93f5ic9vc1Pen6bn/TyLj/p8fA2P+nyNj9po3ukcbi+6DHW5ctP2uge6cFPOt7mJ210j/TgJ210j/TgJ210j/TgJ210j/TgJ210j/T9Tzoa3SM9+Ekb3SM9+Ekb3SPtv/a7fXy5GxyN7pEe/KTjbX7SRvdID37SRvdID37SRvdID37SRvdID37SRvdI3/+kW6N7pAc/aaN7pAc/aaN7pPO4HtOO8+nL3eDW6B7pwU863uYnbXSP9OAnbXSP9OAnbXSP9OAnbXSP9OAnbXSP9P1Puje6R3rwkza6R3rwk6bvkS7n2+8/Hg4Pf9TT4Xz91udP3/r+j7qs6+335NbL+PTVy52v3rfrCzl//iW59d6LXg778fY7dYf906/s/fZf29yPApo7oCGg/1BAp+OvgM6nRwE975dY901Acwe0Nwpo+RXQ8S/Q7wW0bL8+hvbL8uirXxjRSUSzR3SeOqJ9HG8RXU4PIlovt0+u9XI6fvrqu/+cYlmu8R8/7oj/cos7163CRUSTR3Q6iGj2iBYRzR7R3KuCiD4imntXENFHRENEs0c097Ygoo+I5l4XRPQR0dzrgog+IrIuTB+RdWH2iM7Whekjsi5MH5F1YfqIrAv/0YhedV50HiKaPaJG68LxcLieuh6XfXsQ0SuhN9oLfg70RgvAcb39ub7jup0fQP/4ALpyWcdn5OMh8V+fc3/8bblzI0f/nRAv23aD+KmJd1/12K8/4rh84r3/k3cj4f6NvNfDYbl+8WEd/9d5XxrZ8+/k/fHDXL94OV7+zYfEpZHf/k6IH1/962c8fl/a5fjrZxyfLoR/Em+kqz+EeCP7nIb4drzdG27bXvgUH8KZN5xOxjlNOLe/drhsl8L95qWTmbYLp5PBLpf9VziXB+F8TMXX2XiMz3PavXCOpxvD43k5fv7if0DsZLC/EeL5cjWq4+UrxE5a+iqIHz8Jik+g2Mk2X0exk0G+jmInK3wdxYHiEyh28qzXUewkRK+jyFyeQbGruuyPfp3i45Jw+xkPn//CzD2K23K5yvn2MQF8odjVXaIUl67ukqXY1V2yFLu6y5MprrenBm7rvn+h2NVdshQHik+g2NVdshS7usuTKe6n6133dloe3KKffv2++2k/f7lFX7qKzsTIWdF/CPl5uSE/b2sNOYX6Dcgv15/xdFqWf4t85Vtx5FP/hd7l1z9HWU6HvxD/54uf+sEEj168Y5T/2Fx4eyHH83b60t+B4hMovlJFltNfKP7z9Tzhpv54w7N+/PQPXs/669dpPoI6PvjqF/4Dn+UZjxnviuYJN8nH29VyHWP9yw/7z/+JJ9wUbrd/S7Zu6+UBz+102W7X+uXwl8+Ef7ygZzy3+7kvaJntBT3hJmG7mcK6nU6P3gLL8VNLx9cXdJztBY3ZXtA22wvan1Hq468XdP7yyXL/0cj7+Xqnv1/W7/8HlsPx9hu4h/OvT9Lz/V/XvdE5fBaIy91vfNiXX1frw6M/f3C8ne+O4/r9B/p6vn2grx93KA8+/Z94qbj/eGa0fxPtC9o52vcfU432b6K9VGkv++0qsn5yobu019u9zvHw4Pvu4/YSPv+7kOPyx8tef+bLPv7Mlz1+5svevn/Zp09/OuHf+STZf713Dstf/gfufPW63z53jp8+HD4+hP54OftcL+c018s5z/VyLlO9nO2QfTnH7baCjHX5y8u5+4bt+MfLlm0BPQ99BT0P/Qh6HvoAPQ99Az0PfQc9D/0Eeh76GfQ89Avoceg7I30BdEb6AuiM9AXQ39hIX/YbSPsbG+nroM9spD/mL4cv+8yO+bK/Bb7sM1vgT/jr3ss+s9L9hL/Xvewz+9nL/gL3cprZoH7GX3heTjML0U9hOLPftPvTystpZrNpiHvAnfvzx8tpapvph3tq63nV349eTlNbz8v+ON1papV5HZap/eRlWM5T+8nrsEytHK/DMrVFvA7L1Hf7r8MyYLmHZeq759dhede73AdYfsxdbvRPjZ5/zF1uFsuPucuNYrn8mLvcLJYfc5cb/XOdlx9zl5vF8mPucrNYBiz3sPyYu9x5/6Lq5cfcEk/M8F3vn5/4Z2Yv73qz/cQ/Ynp51zvz5zFcD+Hb+O//vf56WOZ6OW87zn73d0PXw9uOs99jGWEsv/6Vwb/F8s+XU75d/Dgmv/4PfFbd+y/n4yD/+pvj6/j0qyfH4+mPl1O+8zrefgthOX76+5D/Dp3Trxd/Xn+9nPO9zpxvf6TvvP76Pa/L3c/Tm/6fLue//JB3+rJuh1sVP/8SwuUPIqf3I3Lcbv+8YHz6q51XImcd+TdELjryVyLLQUf+DZFFR/4NkVVH/g2Ro478GyLj/Yh8+9t/67JNTORy+yeyh/EIyen6Ki6f7ug/XtEfP+XE96HLYfv1Y376g9R3f8ztdDjdJr1P/9Bo+cc/8vzy1evHYcPtT7Z+KNL2l6//J5iJb0dfC+apd6WfBpv7YI777WPr9Avi5a5zHX/9yfzjpzf0crpLfLv9WsSyf3qIyf1/23u8XF/GOH768/qHu/9qsN9f+F2Xy7Spr6cbkuPhUeqXy35lcrmctwfvhuWwjl/vtPW8fHk3rAdc7nJZcLnLZcXlLpfje3LZx6+/Mr9/frDQlcvA5S6X7S25fKzZ669N/HJ58PXvftey7lqyLOPru+f0nlx+/cvNj//+9E83b1zmdZvXcnnPu/+HXI7veff/mMt73v0/5vKed/+Pubzn3f9jLgOXu1ze9O7/IZc3vd99yMX97n0u7nfvc3G/e5fLcL97n4v73ftc3O/e5+J+9z6XgctdLu5373Nxv3ufi/vd+1zc797n4n73LpfN/e59Lu5373Nxv3ufi/vd+1wGLne5uN+9z8X97n0u7nfvc3G/e5+L+927XHb3u/e5uN+9z8X97n0u7nfvcxm43OXifvc+F/e797m4373Pxf3ufS7ud+9yObnfvc/F/e59Lu5373Nxv3ufy8DlLhf3u/e5uN+9z8X97n0u7nfvc3G/e5fL2f3ufS7ud+9zcb97n4v73ftcBi53ubjfvc/F/e59Lu5373Nxv3ufi/vdu1wu7nfvc3G/e5+L+937XNzv3ucycLnLxf3ufS7ud+9zcb97n4v73ftc3O/e43I8uN+9z8X97n0u7nfvc3G/e5/LwOUul3nvd4+X64Nw1rFdHnA579dXcb5sD772uB+uP95xXz494e4e7+X6Ii7j8Jfv+096894V/wR68947/wR6Ez/N5O/QW5bD9usjannw1X/nMUlj3a7Pjxnr6ReNfzyk5ssXb+Nwe2b7+PSwmY8v/iftee/bG9Je5rWBjrTndYyOtOc1l4605/WhjrQH2kHaTdzth9Bu4no/hHYTN/whtLlkkjaXDNKe+DmXHWlzySRtLpmkzSWTtAfaQdpcMkmbSyZpc8kkbS6ZpM0lg7QnfmpqR9pcMkmbSyZpc8kk7YF2kDaXTNLmkknaXDJJm0smaXPJIO2Jn0jckTaXTNLmko9o74frF499PXwBSA+LAAeANYAkrgiQlz0EuG03gKevAKlWESB7KgIkRDWAEz+F+ocApC21q/DEz7X+IQCZSBHgALAGkIkULyJMpAiQiRQBMpEiQCZSAzjx88F/CEAmUgTIRIoAmUgR4ACwBpCJFAEykSJAJlIEyESKAJlIbc6a+MntPwQgEykCZCJFgEykdhGZ+OnyPwQgEykCZCJFgEykCJCJFAEykRrAMxMpAmQiRYBMpAiQiRQBDgBrAJlIESATKQJkIrU568xEigCZSA3ghYkUATKR2kXkwkSKAJlIEeAAsAaQiRQBMpEiQCZSBMhEigCZSAngODCRIkAmUgTIRIoAmUgR4ACwBpCJlOascWAiRYBMpAiQiRQBMpHaRWRhIkWATKQIkIkUATKRIsABYA0gEykCZCJFgEykCJCJFAEykRrAlYkUATKRIkAmUgTIRGpz1joArAFkIkWATKQIkIkULyJMpAiQidQAHplIESATKQJkIkWATKQIcABYA8hEigCZSBEgEykCZCJFgEykBtDT26sAmUhtzvKM9SpAJlIEOACsAWQixYsIEykCZCJFgEykCJCJ1AB6xnoVIBMpAmQiRYBMpAhwAFgDyESKAJlIESATKQJkIkWATKQ2Z3nGehUgEykCZCJFgEykdhHxjPUqQCZSBMhEigCZSBEgEykCZCI1gJ6xXgXIRIoAmUgRIBMpAhwA1gAykSJAJlIEyERqc5ZnrFcBMpEaQM9YrwJkIrWLiGesVwEykSLAAWANIBMpAmQiRYBMpAiQiRQBMpEaQM9YrwJkIkWATKQIkIkUAQ4AawCZSG3O8oz1KkAmUgTIRIoAmUjpIrJ5xnoVIBMpAmQiRYBMpAhwAFgDyESKAJlIESATKQJkIkWATKQG0DPWqwCZSBEgEykCZCKlOWvzjPUqQCZSBMhEigCZSPEiwkSKAJlIDaBnrFcBMpEiQCZSBMhEigAHgDWATKQIkIkUATKRIkAmUgTIRGoAPWO9CpCJ1OYsz1ivAmQiRYADwBpAJlK8iDCRIkAmUgTIRIoAmUgNoGesVwEykSJAJlIEyESKAAeANYBMpAiQiRQBMpEiQCZSBMhEanOWZ6xXATKRIkAmUgTIRGoXEc9YrwJkIkWATKQIkIkUATKRIkAmUgPoGetVgEykCJCJFAEykSLAAWANIBMpAmQiRYBMpDZnecZ6FSATqQH0jPUqQCZSu4h4xnoVIBMpAhwA1gAykSJAJlIEyESKAJlIESATqQH0jPUqQCZSBMhEigCZSBHgALAGkInU5izPWK8CZCJFgEykCJCJ1C4inrFeBchEigCZSBEgEykCHADWADKRIkAmUgTIRIoAmUgRIBMpAdw9Y70KkIkUATKRIkAmUpqzPv4/AawBZCJFgEykCJCJFC8iTKQIkInUAHrGehUgEykCZCJFgEykCHAAWAPIRIoAmUgRIBMpAmQiRYBMpAbQM9arAJlIbc7yjPUqQCZSBDgArAFkIsWLCBMpAmQiRYBMpAiQidQAesZ6FSATKQJkIkWATKQIcABYA8hEigCZSBEgEykCZCJFgEykNmd5xnoVIBMpAmQiRYBMpHYR8Yz1KkAmUgTIRIoAmUgRIBMpAmQiNYCesV4FyESKAJlIESATKQIcANYAMpEiQCZSBMhEanOWZ6xXATKRGkDPWK8CZCK1i4hnrFcBMpEiwAFgDSATKQJkIkWATKQIkIkUATKRGkDPWK8CZCJFgEykCJCJFAEOAGsAmUhtzvKM9SpAJlIEyESKAJlI7SLiGetVgEykCJCJFAEykSLAAWANIBMpAmQiRYBMpAiQiRQBMpEaQM9YrwJkIkWATKQIkInU5izPWK8CZCJFgEykCJCJFC8iTKQIkImUAJ48Y70KkIkUATKRIkAmUgQ4AKwBZCJFgEykCJCJFAEykSJAJlID6BnrVYBMpDRnnTxjvQqQiRQBDgBrAJlI8SLCRIoAmUgRIBMpAmQiNYCesV4FyESKAJlIESATKQIcANYAMpEiQCZSBMhEigCZSBEgE6nNWZ6xXgXIRIoAmUgRIBOpXUQ8Y70KkIkUATKRIkAmUgTIRIoAmUgNoGesVwEykSJAJlIEyESKAAeANYBMpAiQiRQBMpHanOUZ61WATKQG0DPWqwCZSO0i4hnrVYBMpAhwAFgDyESKAJlIESATKQJkIkWATKQG0DPWqwCZSBEgEykCZCJFgAPAGkAmUpuzPGO9CpCJFAEykSJAJlK7iHjGehUgEykCZCJFgEykCHAAWAPIRIoAmUgRIBMpAmQiRYBMpAbQM9arAJlIESATKQJkIrU5yzPWqwCZSBEgEykCZCLFiwgTKQJkIjWAnrFeBchEigCZSBEgEykCHADWADKRIkAmUgTIRIoAmUgRIBMpATx7xnoVIBMpzVlnz1ivAmQiRYADwBpAJlK8iDCRIkAmUgTIRIoAmUgNoGesVwEykSJAJlIEyESKAAeANYBMpAiQiRQBMpEiQCZSBMhEanOWZ6xXATKRIkAmUgTIRGoXEc9YrwJkIkWATKQIkIkUATKRIkAmUgPoGetVgEykCJCJFAEykSLAAWANIBMpAmQiRYBMpDZnecZ6FSATqQH0jPUqQCZSu4h4xnoVIBMpAhwA1gAykSJAJlIEyESKAJlIESATqQH0jPUqQCZSBMhEigCZSBHgALAGkInU5izPWK8CZCJFgEyk+BnIRGoAPWO9CpCJFAEykSJAJlIEOAAs3cZ4xnoVIBMpAmQixc9AJlIEyERqAD1jvQqQiRQBMpEiQCZSu43xjPUqQCZSBMhEigCZSPEiwkSKAJlIDaBnrFcBMpEiQCZSBMhEigAHgDWATKQIkIkUATKRRwBPNxgf/3n8ApCJPAK4bqcrwPX0F4Bfv3gbh/3PL97GOr7Qpi1B2p7eHqVNiJK02VOSNtVK0h5oB2mTuCRtxpekTQ+TtLlkkjaXzNG+HLhkkjaXTNLmkknaXDJJe6AdpM0lk7S5ZJI2l0zS5pJJ2lwySHvhkknaXDJJm0smaXPJJO2BdpA2l0zS5pJJ2lwySZtLJmlzySDtlUsmaXPJJG0u+Yj2t/9O/7LSwyLAAWANIIkrAuRlDwF+9y8ELyvVKgJkT0WAhKgG8MhxigBpS+0qfGQiRYBMpAhwAFgDyESKFxEmUgTIRIoAmUgRIBOpARxMpAiQiRQBMpEiQCZSBDgArAFkIkWATKQIkIkUATKRIkAmUpuzNiZSBMhEigCZSBEgE6ldRLYBYA0gEykCZCJFgEykCJCJFAEykRrAnYkUATKRIkAmUgTIRIoAB4A1gEykCJCJFAEykdqctTORIkAmUgN4YiJFgEykdhE5MZEiQCZSBDgArAFkIkWATKQIkIkUATKRIkAmUgN4ZiJFgEykCJCJFAEykSLAAWANIBOpzVlnJlIEyESKAJlIESATqV1ELkykCJCJFAEykSJAJlIEOACsAWQiRYBMpAiQiRQBMpEiQCZSArgcDlSkSpCLVAmSkSpBNlKatD4IDgSLBPlIlSAhqRJkJNUrCSWpEuQkRYILJ6kS5CRVgpykSpCTVAkOBIsEOUmVICepEuQkVYKcpEqQkxQJeqR7mSAnKa5bHr1eJshJqgQHgkWCnKR6JeEkVYKcpEqQk1QJcpIiQY9gLxPkJFWCnKRKkJNUCQ4EiwQ5SZUgJ6kS5CRVgpykSpCTFNctD2MvE+QkVYKcpEqQkxSvJB7IXibISaoEOUmVICepEuQkVYKcpEjQY9nLBDlJlSAnqRLkJFWCA8EiQU5SJchJqgQ5SXHd8nj2MkFOUiToAe1lgpykeCXxiPYyQU5SJTgQLBLkJFWCnKRKkJNUCXKSKkFOUiToUe1lgpykSpCTVAlykirBgWCRICcprlse2F4myEmqBDlJlSAnKV5JPLS9TJCTVAlykipBTlIlOBAsEuQkVYKcpEqQk1QJcpIqQU5SJOjx7WWCnKRKkJNUCXKS4rrlEe5lgpykSpCTVAlykuqVhJNUCXKSGsHFc9zLBDlJlSAnqRLkJFWCA8EiQU5SJchJqgQ5SZUgJ6kS5CRFgp7jXibISWrr1uI57mWCnKRKcCBYJMhJqlcSTlIlyEmqBDlJlSAnKRL0HPcyQU5SJchJqgQ5SZXgQLBIkJNUCXKSKkFOUiXISaoEOUlx3fIc9zJBTlIlyEmqBDlJ8UriOe5lgpykSpCTVAlykipBTlIlyEmKBD3HvUyQk1QJcpIqQU5SJTgQLBLkJFWCnKRKkJMU1y3PcS8T5CRFgp7jXibISYpXEs9xLxPkJFWCA8EiQU5SJchJqgQ5SZUgJ6kS5CRFgp7jXibISaoEOUmVICepEhwIFglykuK65TnuZYKcpEqQk1QJcpLilcRz3MsEOUmVICepEuQkVYIDwSJBTlIlyEmqBDlJlSAnqRLkJEWCnuNeJshJqgQ5SZUgJymuW57jXibISaoEOUmVICepXkk4SZUgJykS9Bz3MkFOUiXISaoEOUmV4ECwSJCTVAlykipBTlIlyEmqBDlJjeDqOe5lgpyktm6tnuNeJshJqgQHgkWCnKR6JeEkVYKcpEqQk1QJcpIiQc9xLxPkJFWCnKRKkJNUCQ4EiwQ5SZUgJ6kS5CRVgpykSpCTFNctz3EvE+QkVYKcpEqQkxSvJJ7jXibISaoEOUmVICepEuQkVYKcpEjQc9zLBDlJlSAnqRLkJFWCA8EiQU5SJchJqgQ5SXHd8hz3MkFOUiToOe5lgpykeCXxHPcyQU5SJTgQLBLkJFWCnKRKkJNUCXKSKkFOUiToOe5lgpykSpCTVAlykirBgWCRICcprlue414myEmqBDlJlSAnKV5JPMe9TJCTVAlykipBTlIlOBAsEuQkVYKcpEqQk1QJcpIqQU5SJOg57mWCnKRKkJNUCXKS4rrlOe5lgpykSpCTVAlykuqVhJNUCXKSIkHPcS8T5CRVgpykSpCTVAkOBIsEOUmVICepEuQkVYKcpEqQkxQJeo57mSAnKa5bnuNeJshJqgQHgkWCnKR6JeEkVYKcpEqQk1QJcpIawaPnuJcJcpIqQU5SJchJqgQHgkWCnKRKkJNUCXKSKkFOUiXISWrr1tFz3MsEOUmVICepEuQkxSuJ57iXCXKSKkFOUiXISaoEOUmVICcpEvQc9zJBTlIlyEmqBDlJleBAsEiQk1QJcpIqQU5SXLc8x71MkJMUCXqOe5kgJyleSTzHvUyQk1QJDgSLBDlJlSAnqRLkJFWCnKRKkJMUCXqOe5kgJ6kS5CRVgpykSnAgWCTISYrrlue4lwlykipBTlIlyEmKVxLPcS8T5CRVgpykSpCTVAkOBIsEOUmVICepEuQkVYKcpEqQkxQJeo57mSAnqRLkJFWCnKS4bnmOe5kgJ6kS5CRVgpykeiXhJFWCnKRI0HPcywQ5SZUgJ6kS5CRVggPBIkFOUiXISaoEOUmVICepEuQkRYKe414myEmK65bnuJcJcpIqwYFgkSAnqV5JOEmVICepEuQkVYKcpEjQc9zLBDlJlSAnqRLkJFWCA8EiQU5SJchJqgQ5SZUgJ6kS5CS1dWt4jnuZICepEuQkVYKcpHYlGYeBYJEgJ6kS5CRVgpykSpCTVAlykiJBz3EvE+QkVYKcpEqQk1QJDgSLBDlJlSAnqRLkJMV1y3PcywQ5SZGg57iXCXKS4pXEc9zLBDlJleBAsEiQk1QJcpIqQU5SJchJqgQ5SZGg57iXCXKSKkFOUiXISaoEB4JFgpykuG55jnuZICepEuQk1c9BTlIk6DnuZYKcpEqQk1QJcpIqwYFg7W7Gc9zLBDlJlSAnqX4OcpIqQU5SJOg57mWCnKRKkJNUCXKS4t2M57iXCXKSKkFOUiXISapXEk5SJchJigQ9x71MkJNUCXKSKkFOUiU4ECwS5CRVgpykSpCTPCJ4usH4+M/jV4Kc5BHBdTtdCa6nvxD8+sXbOOx/fvE21vEVN4FJ4vaE+CxuahTFzaOiuElXFPeAO4mbzkVxc78obqIYxc0qo7hZZRL3mVVGcbPKKG5WGcXNKqO4B9xJ3KwyiptVRnGzyihuVhnFzSqTuC+sMoqbVUZxs8ooblYZxT3gTuJmlVHcrDKKm1VGcbPKKG5WGcS9HVhlFDerjOJmlY9wf/+v+rcDUawSHAgWCdK5KkGG9pDgt/+ScDuQripBHlUlSI2KBBe2UyVIYIrX4oWTVAlykirBgWCRICepXkk4SZUgJ6kS5CRVgpykSHDlJFWCnKRKkJNUCXKSKsGBYJEgJ6kS5CRVgpykSpCTVAlykuK6deQkVYKcpEqQk1QJcpLileQ4ECwS5CRVgpykSpCTVAlykipBTlIkODhJlSAnqRLkJFWCnKRKcCBYJMhJqgQ5SZUgJymuW4OTVAlykiLBjZNUCXKS4pVk4yRVgpykSnAgWCTISaoEOUmVICepEuQkVYKcpEhw5yRVgpykSpCTVAlykirBgWCRICcprls7J6kS5CRVgpykSpCTFK8kJ05SJchJqgQ5SZUgJ6kSHAgWCXKSKkFOUiXISaoEOUmVICcpEjxzkipBTlIlyEmqBDlJcd06DwSLBDlJlSAnqRLkJNUrCSepEuQkRYIXTlIlyEmqBDlJlSAnqRIcCBYJcpIqQU5SJchJqgQ5SZUgJ6kR3D0hvkyQk9TWrd1z3MsEOUmV4ECwSJCTVK8knKRKkJNUCXKSKkFOUiToOe5lgpykSpCTVAlykirBgWCRICepEuQkVYKcpEqQk1QJcpLiuuU57mWCnKRKkJNUCXKS4pXEc9zLBDlJlSAnqRLkJFWCnKRKkJMUCXqOe5kgJ6kS5CRVgpykSnAgWCTISaoEOUmVICcprlue414myEmKBD3HvUyQkxSvJJ7jXibISaoEB4JFgpykSpCTVAlykipBTlIlyEmKBD3HvUyQk1QJcpIqQU5SJTgQLBLkJMV1y3PcywQ5SZUgJ6kS5CTFK4nnuJcJcpIqQU5SJchJqgQHgkWCnKRKkJNUCXKSKkFOUiXISYoEPce9TJCTVAlykipBTlJctzzHvUyQk1QJcpIqQU5SvZJwkipBTlIk6DnuZYKcpEqQk1QJcpIqwYFgkSAnqRLkJFWCnKRKkJNUCXKSIkHPcS8T5CTFdctz3MsEOUmV4ECwSJCTVK8knKRKkJNUCXKSKkFOUiN48hz3MkFOUiXISaoEOUmV4ECwSJCTVAlykipBTlIlyEmqBDlJbd06eY57mSAnqRLkJFWCnKR4JfEc9zJBTlIlyEmqBDlJlSAnqRLkJEWCnuNeJshJqgQ5SZUgJ6kSHAgWCXKSKkFOUiXISYrrlue4lwlykiJBz3EvE+QkxSuJ57iXCXKSKsGBYJEgJ6kS5CRVgpykSpCTVAlykiJBz3EvE+QkVYKcpEqQk1QJDgSLBDlJcd3yHPcyQU5SJchJqgQ5SfFK4jnuZYKcpEqQk1QJcpIqwYFgkSAnqRLkJFWCnKRKkJNUCXKSIkHPcS8T5CRVgpykSpCTFNctz3EvE+QkVYKcpEqQk1SvJJykSpCTFAl6jnuZICepEuQkVYKcpEpwIFgkyEmqBDlJlSAnqRLkJFWCnKRI0HPcywQ5SXHd8hz3MkFOUiU4ECwS5CTVKwknqRLkJFWCnKRKkJMUCXqOe5kgJ6kS5CRVgpykSnAgWCTISaoEOUmVICepEuQkVYKcpLZunT3HvUyQk1QJcpIqQU5Su5KcDwPBIkFOUiXISaoEOUmVICepEuQkRYKe414myEmqBDlJlSAnqRIcCBYJcpIqQU5SJchJiuuW57iXCXKSIkHPcS8T5CTFK4nnuJcJcpIqwYFgkSAnqRLkJFWCnKRKkJNUCXKSIkHPcS8T5CRVgpykSpCTVAkOBIsEOUlx3fIc9zJBTlIlyEmqBDlJ8UriOe5lgpykSpCTVAlykirBgWCRICepEuQkVYKcpEqQk1QJcpIiQc9xLxPkJFWCnKRKkJMU1y3PcS8T5CRVgpykSpCTVK8knKRKkJMUCXqOe5kgJ6kS5CRVgpykSnAgWCTISaoEOUmVICepEuQkVYKcpEjQc9zLBDlJcd3yHPcyQU5SJTgQLBLkJNUrCSepEuQkVYKcpEqQkxQJeo57mSAnqRLkJFWCnKRKcCBYJMhJqgQ5SZUgJ6kS5CRVgpykuG55jnuZICepEuQkVYKcpHgl8Rz3MkFOUiXISaoEOUmVICepEuQkNYIXz3EvE+QkVYKcpEqQk1QJDgSLBDlJlSAnqRLkJLV16+I57mWCnKRI0HPcywQ5SfFK4jnuZYKcpEpwIFgkyEmqBDlJlSAnqRLkJFWCnKRI0HPcywQ5SZUgJ6kS5CRVggPBIkFOUly3PMe9TJCTVAlykipBTlK8kniOe5kgJ6kS5CRVgpykSnAgWCTISaoEOUmVICepEuQkVYKcpEjQc9zLBDlJlSAnqRLkJMV1y3PcywQ5SZUgJ6kS5CTVKwknqRLkJEWCnuNeJshJqgQ5SZUgJ6kSHAgWCXKSKkFOUiXISaoEOUmVICcpEvQc9zJBTlJctzzHvUyQk1QJDgSLBDlJ9UrCSaoEOUmVICepEuQkRYKe414myEmqBDlJlSAnqRIcCBYJcpIqQU5SJchJqgQ5SZUgJymuW57jXibISaoEOUmVICcpXkk8x71MkJNUCXKSKkFOUiXISaoEOUmRoOe4lwlykipBTlIlyEmqBAeCRYKcpEqQk1QJcpLiuuU57mWCnKREcD14jnuZICcpXUk+CHKSKkFOUiU4ECwS5CRVgpykSpCTVAlykipBTlIk6DnuZYKcpEqQk1QJcpIqwYFgkSAnKa5bnuNeJshJqgQ5SfVzkJMUCXqOe5kgJ6kS5CRVgpykSnAgWLub8Rz3MkFOUiXISaqfg5ykSpCTFAl6jnuZICepEuQkVYKcpHg34znuZYKcpEqQk1QJcpLqlYSTVAlykiJBz3EvE+QkVYKcpEqQk1QJDgSLBDlJlSAnqRLkJI8Inm4wPv7z+JUgJ3lEcN1OV4Lr6S8Ev37xNg77n1+8jXV8xU1gkrg9IT6LmxpFcfOoKG7SFcU94E7ipnNR3NwvipsoRnGzyihuVpnEvbPKKG5WGcXNKqO4WWUU94A7iZtVRnGzyihuVhnFzSqjuFllEveJVUZxs8ooblYZxc0qo7gH3EncrDKKm1VGcbPKKG5WGcXNKpO4z6wyiptVRnGzyke4H/yr/jNRrBIcCBYJ0rkqQYb2kOD3/5LwTLqqBHlUlSA1KhK8sJ0qQQJTvBZfOEmVICepEhwIFglykuqVhJNUCXKSKkFOUiXISWoElwMnqRLkJFWCnKRKkJNUCQ4EiwQ5SZUgJ6kS5CRVgpykSpCT1Natj/9hBIsEOUmVICepEuQkxSvJMhAsEuQkVYKcpEqQk1QJcpIqQU5SJLhykipBTlIlyEmqBDlJleBAsEiQk1QJcpIqQU5SXLdWTlIlyEmKBI+cpEqQkxSvJEdOUiXISaoEB4JFgpykSpCTVAlykipBTlIlyEmKBAcnqRLkJFWCnKRKkJNUCQ4EiwQ5SXHdGpykSpCTVAlykipBTlK8kmycpEqQk1QJcpIqQU5SJTgQLBLkJFWCnKRKkJNUCXKSKkFOUiS4c5IqQU5SJchJqgQ5SXHd2geCRYKcpEqQk1QJcpLqlYSTVAlykiLBEyepEuQkVYKcpEqQk1QJDgSLBDlJlSAnqRLkJFWCnKRKkJMUCXpCfJkgJymuW57jXibISaoEB4JFgpykeiXhJFWCnKRKkJNUCXKSIkHPcS8T5CRVgpykSpCTVAkOBIsEOUmVICepEuQkVYKcpEqQk9TWrdVz3MsEOUmVICepEuQktSvJehgIFglykipBTlIlyEmqBDlJlSAnKRL0HPcyQU5SJchJqgQ5SZXgQLBIkJNUCXKSKkFOUly3PMe9TJCTFAl6jnuZICcpXkk8x71MkJNUCQ4EiwQ5SZUgJ6kS5CRVgpykSpCTFAl6jnuZICepEuQkVYKcpEpwIFgkyEmK65bnuJcJcpIqQU5SJchJilcSz3EvE+QkVYKcpEqQk1QJDgSLBDlJlSAnqRLkJFWCnKRKkJMUCXqOe5kgJ6kS5CRVgpykuG55jnuZICepEuQkVYKcpHol4SRVgpykSNBz3MsEOUmVICepEuQkVYIDwSJBTlIlyEmqBDlJlSAnqRLkJEWCnuNeJshJiuuW57iXCXKSKsGBYJEgJ6leSThJlSAnqRLkJFWCnKRI0HPcywQ5SZUgJ6kS5CRVggPBIkFOUiXISaoEOUmVICepEuQkxXXLc9zLBDlJlSAnqRLkJMUriee4lwlykipBTlIlyEmqBDlJlSAnqRE8eo57mSAnqRLkJFWCnKRKcCBYJMhJqgQ5SZUgJ6mtW0fPcS8T5CRFgp7jXibISYpXEs9xLxPkJFWCA8EiQU5SJchJqgQ5SZUgJ6kS5CRFgp7jXibISaoEOUmVICepEhwIFglykuK65TnuZYKcpEqQk1QJcpLilcRz3MsEOUmVICepEuQkVYIDwSJBTlIlyEmqBDlJlSAnqRLkJEWCnuNeJshJqgQ5SZUgJymuW57jXibISaoEOUmVICepXkk4SZUgJykS9Bz3MkFOUiXISaoEOUmV4ECwSJCTVAlykipBTlIlyEmqBDlJkaDnuJcJcpLiuuU57mWCnKRKcCBYJMhJqlcSTlIlyEmqBDlJlSAnKRL0HPcyQU5SJchJqgQ5SZXgQLBIkJNUCe4IFglykipBTlIlyEmK65bnuJcJcpIqQU5SJchJilcSz3EvE+QkVYKcpEqQk1QJcpIqQU5SJOg57mWCnKRKkJNUCXKSKsGBYJEgJ6kS5CRVgpykuG55jnuZICepERye414myElqV5LhOe5lgpykSnAgWCTISaoEOUmVICepEuQkVYKcpEjQc9zLBDlJlSAnqRLkJFWCA8EiQU5SXLc8x71MkJNUCXKSKkFOUrySeI57mSAnqRLkJFWCnKRKcCBYJMhJqgQ5SZUgJ6kS5CRVgpykSNBz3MsEOUmVICepEuQkxXXLc9zLBDlJlSAnqRLkJNUrCSepEuQkRYKe414myEmqBDlJlSAnqRIcCBYJcpIqQU5SJchJqgQ5SZUgJykS9Bz3MkFOUly3PMe9TJCTVAkOBIsEOUn1SsJJqgQ5SZUgJ6kS5CRFgp7jXibISaoEOUmVICepEhwIFglykipBTlIlyEmqBDlJlSAnKa5bnuNeJshJqgQ5SZUgJyleSTzHvUyQk1QJcpIqQU5SJchJqgQ5SZGg57iXCXKSKkFOUiXISaoEB4JFgpykSpCTVAlykuK65TnuZYKcpEjQc9zLBDlJ8UriOe5lgpykSnAgWCTISaoEOUmVICepEuQkVYKcpEZw8xz3MkFOUiXISaoEOUmV4ECwSJCT1NatzXPcywQ5SZUgJ6kS5CTFK4nnuJcJcpIqQU5SJchJqgQHgkWCnKRKkJNUCXKSKkFOUiXISYoEPce9TJCTVAlykipBTlJctzzHvUyQk1QJcpIqQU5SvZJwkipBTlIk6DnuZYKcpEqQk1QJcpIqwYFgkSAnqRLkJFWCnKRKkJNUCXKSIkHPcS8T5CTFdctz3MsEOUmV4ECwSJCTVK8knKRKkJNUCXKSKkFOUiToOe5lgpykSpCTVAlykirBgWCRICepEuQkVYKcpEqQk1QJcpLiuuU57mWCnKRKkJNUCXKS4pXEc9zLBDlJlSAnqRLkJFWCnKRKkJMUCXqOe5kgJ6kS5CRVgpykSnAgWCTISaoEOUmVICcprlue414myEmKBD3HvUyQkxSvJJ7jXibISaoEB4JFgpykSpCTVAlykipBTlIlyEmKBD3HvUyQk1QJcpIqQU5SJTgQLBLkJMV1y3PcywQ5SZUgJ6l+DnKSGsHdc9zLBDlJlSAnqRLkJFWCA8HS3czuOe5lgpykSpCTVD8HOUmVICcpEvQc9zJBTlIlyEmqBDlJ8W7Gc9zLBDlJlSAnqRLkJNUrCSepEuQkRYKe414myEmqBDlJlSAnqRIcCBYJcpIqQU5SJchJHhE83WB8/OfxK8EuTrJuh9vLOD766vN+fc3ny6+fb9kvd1/yerm+5v0fjD999R8Iu0jJ70N4uuzX13xeH371r9dxXD997/VP3m0e+z4L7+N2+wnHcvjKu4vw/D7e57HeeO+nB189xnL96vHxf37xHnej3E+3b70cP3/xH+F0cakfGc75cuV8vNwLp4umtQxnCGfecLrIZctwunhry3C6KHHLcNj2xOHw+HnDGaR/4nDeciFYDuO6siyH0/oA+LouVxzr+unXa47rei/4sV6/93lcPn3v05/E31L7/ybx4/H6I67HcXlE/Hy6ET+f98/E78WzHG7xLPvXeN5S/CeK58G7Z4hn5nfPW8r/z4nnLfX/58TzlgPAz4nnLSeAnxPPW44APyae7S1ngB9zY70ZAqZ+91gNpn73WA2mfvcM8cwcj9Vg6nisBlNfe6wGU797rAZTx2M1mDme3WowdTxWg5lvDXarwdTvHqvB1PEM8cwcj9Vg6muP1WDqd4/VYOp3j9Vg6neP1WDmd8/JajDzu+dkNZg6HqvB1PFYDaa+9gzxzPzusRpM/e6xGkz97rEaTP3usRpM/e6xGswcz9lqMHU8VoOZrz1nq8HU7x6rwdTxDPHM/OFmNZj63WM1mPrdYzWY+t1jNZj63WM1mPndc7EaTB2P1WDqeKwGU8djNZg6niGeie/cLlaDqd89VoOp47EaTB2P1WDqa4/VYOJ3z+lgNZj43XM6WA2mfvdYDaaOx2owdTxDPDPHYzWY+tbAajD1u8dqMPW7x2ow9bvHajBzPIvVYOYPt8VqMPW7x2owdTxWg6njGeKZOR6rwdTxWA2mjsdqMHU8VoOp47EazKylq9Vg5nfPajWYOh6rwdQfblaDqd89Qzwzx2M1mDoeq8HU1x6rwdTvHqvB1O8eq8HM756j1WDqeKwGM3+4Ha0GU797rAZTv3uGeGZ+91gNpn73WA2mfvdYDaaOx2owdTxWg5njGVaDqeOxGsx85zasBlO/e6wGU8czxDPzh5vVYOp3j9Vg6nisBlPHYzWYOh6rwczxbFaDqeOxGsx8Y71ZDaZ+91gNpo5niGfmeKwGU8djNZj61sBqMPW7x2owdTxWg5k/3Harwczvnt1qMPW7x2ow9bvHajB1PEM8M3+4WQ2mfvdYDaZ+91gNpn73WA2mjsdqMPOH28lqMPO752Q1mPrdYzWY+t1jNZg6niGemT/crAZTv3usBlPHYzWYOh6rwdTxWA1mjudsNZg6HqvB1PFYDWb2nrPVYOp3zxDPzO8eq8HU7x6rwdTxWA2mjsdqMHU8VoOZ47lYDaaOx2owdTxWg5m952I1mPrdM8QzczxWg6k/3KwGU797rAZTx2M1mPrDzWow8bvnfLAaTPzuOR+sBlO/e6wGU8djNZg6niGemeOxGkwdj9Vg6js3q8HU7x6rwdTxWA1m/nBbrAYzv3sWq8HU7x6rwdTvHqvB1O+eIZ6Z3z1Wg6njsRpM/eFmNZj63WM1mDoeq8HM8axWg5mvPavVYOp3j9Vg6nisBlN/uA3xzPzusRpMHY/VYOp4rAZTx2M1mDoeq8HM8RytBjPfWB+tBlO/e6wGU797rAZTv3uGeGaOx2owdTxWg6mvPVaDqd89VoOp3z1Wg5nfPcNqMPO7Z1gNpn73WA2mfvdYDaZ+9wzxzPzusRpM/e6xGkwdj9Vg6g83q8HU7x6rwczxbFaDqeOxGkwdj9Vg6nisBjPfuW1DPDO/e6wGU8djNZg6HqvB1Nceq8HU7x6rwczx7FaDqeOxGkwdj9Vg6nisBjPfue1DPDO/e6wGU797rAZTv3usBlO/e6wGU797rAYzv3tOVoOZ3z0nq8HU8VgNpo7HajD1tWeIZ+Z3j9Vg6neP1WDqd4/VYOp4rAZTf7hZDWZ+95ytBjO/e85Wg6nfPVaDqd89VoOp3z1DPDPHYzWYOh6rwdTXHqvB1O8eq8HU8VgNZv5wu1gNZn73XKwGU797rAZTv3usBlO/e4Z4Zn73WA2mjsdqMHU8VoOp47EaTB2P1WDiO7fLwWow8bvncrAaTB2P1WDqeKwGU197hnhmfvdYDaaOx2owdTxWg6njsRpMfWtgNZj53bNYDaaOx2ow84fbYjWY+t1jNZg6niGemeOxGkwdj9Vg6nisBlPfuVkNpn73WA1mfvesVoOZ3z2r1WDqd4/VYOp3j9Vg6nfPEM/M7x6rwdTvHqvB1O8eq8HU8VgNpo7HajBzPEerwdTxWA1mvnM7Wg2mfvdYDaZ+9wzxzPzusRpM/e6xGkz97rEaTP3usRpM/e6xGsz87hlWg5nfPcNqMHU8VoOpP9ysBlO/e4Z4Zo7HajD1h5vVYOp3j9Vg6neP1WDqd4/VYOZ4NqvB1PFYDWa+9mxWg6nfPVaDqeMZ4pk5HqvB1Nceq8HU7x6rwdTvHqvB1O8eq8HM757dajDzu2e3Gkz97rEaTP3usRpM/e4Z4nlyPJfD9as//vPylbgh4HcSX45fiXP7JxP/AL7++dUf/3n+Spyup4kz8DRxUh0mfuLJaeLUN02czaaJE9Q08YF4mDjnTBPnnGninDNNnHOmiXPOMPEz50wT55xp4pwzTZxzpokPxMPEOWeaOOdME+ecaeKcM02cc4aJXzhnmjjnTBPnnE8nfjrdiJ+//hbchXOmiQ/Ew8Q5Z5o453w68f1yJb4cDl+Jc840cc6ZvjvknFHix8OBc6aJc840cc6ZJs4508QH4mHinDNNnHOmiXPONHHOmSbOOcPEF86ZJs4508Q5Z5o450wTH4iHiXPONHHOmSbOOdPEOWeaOOcME185Z5o450wT55xp4pwz+nuHH8QH4mHinDNNnHOmiXPO6O/WfhDnnGninDN8d3jknGninDNNnHOmiXPONPGBeJg450wT55xp4pwzTZxzpolzzjDxwTnTxDlnmjjnTBPnnGniA/Ewcc6ZJs4508Q5Z5o450wT55xh4hvnTBPnnGninDNNnHOGfwtuG4iHiXPONHHOmSbOOcO/6blxzjRxzhm+O9w5Z5o450wT55xp4pwzTXwgHibOOdPEOWeaOOdME+ecaeKcM0z8xDnTxDlnmjjnTBPnnGniA/Ewcc6ZJs4508Q5Z5o450wT55xh4mfOmSbOOdPEOWf4d7LOnDNNfCAeJs4508Q5Z/j3Ds+cM02cc6bvDjlnmPiFc6aJc840cc6ZJs4508QH4mHinDNNnHOmiXPONHHOmSbOObPEP6YWxMPEOWeaOOdME+ecaeID8TBxzpkmzjnTxDlnmjjnTBPnnGHiC+fM/obQsnDONHHOmSbOOdPEB+LR34JbFs6ZJs4503eHnDNNnHOmiXPOMPGVc6aJc840cc6ZJs4508QH4mHinDNNnHOmiXPONHHOmSbOOcPEj5wzTZxzpolzzjRxzpkmPhAPE+ecaeKcM02cc4Z/X+XIOdPEOWeY+OCcaeKcM/w7WYNzpolzzvDd4RiIh4lzzjRxzpkmzjnTxDlnmjjnDBPfOGeaOOdME+ecaeKcM018IB4mzjnTxDlnmjjnTBPnnGninDNMfOecaeKcM02cc6aJc87wb0/sA/Ewcc6ZJs4508Q5Z/g3hHbOmSbOOcN3hyfOmSbOOdPEOWeaOOdMEx+Ih4lzzjRxzpkmzjnTxDlnmjjnDBM/c840cc6ZJs4508Q5Z5r4QDxMnHOmiXPONHHOmSbOOcNn+WfOGSZ+4Zxp4pwzTZxzhn9f5cI508QH4tm7wwvnTBPnnGninDNNnHOmiXPOLPH1wDnTxDlnmjjnTBPnnGniA/Ewcc6ZJs4508Q5Z5o450wT55xh4gvnTBPnnGninDN7srwunDNNfCAeJs4508Q5Z/a3J9aFc6aJc8703SHnDBNfOWeaOOdME+ecaeKcM018IB4mzjnTxDlnmjjnTBPnnGninDNM/Mg508Q5Z5o450wT55xp4gPxMHHOGT7nPHLONHHOmSbOOdPEOWf4LH9wzjRxzhm+OxycM02cc6aJD8TDxDlnmjjnTBPnnGninDNNnHOGiW+cM02cc6aJc840cc6ZJj4QDxPnnGninDNNnHOGT902zpkmzjnDxHfOmSbOOcMnyzvnTBPnnOG7w30gHibOOdPEOWeaOOdME+ecaeKcM0z8xDnTxDlnmjjnTBPnnGniA/Ewcc6ZJs4508Q5Z5o45wyfAZ04Z5j4mXOmiXPONHHOGT7nPHPONPGBePbu8Mw508Q5Z5o450wT55xp4pwzTPzCOdPEOWeaOOdME+ecaeID8TBxzpkmzjnTxDlnmjjnDJ9IXDhnlvjxwDnTxDlnmjjnzJ66HQ+cM018IB69OzweOGeaOOdME+ecaeKcM02cc4aJL5wzTZxzpolzzjRxzpkmPhAPE+ecaeKcM02cc4b38YVzpolzzjDxlXOmiXPO8BnQyjnTxDln+O5wHYiHiXPONHHOmSbOOdPEOWeaOOcMEz9yzjRxzpkmzjnTxDlnmvhAPEycc4bX2iPnTBPnnGninDNNnHOGTyQG50wT55zhu8PBOdPEOWea+EA8TJxzpolzzjRxzpkmzjnTxDlnmPjGOdPEOWeaOOcMb4cb50wTH4iHiXPONHHOGd7HN86ZJs4503eHnDNMfOecaeKcM02cc6aJc8408YF4mDjnTBPnnGninDNNnHOGl6ydc4aJnzhnmjjnTBPnnOG19sQ508QH4tm7wxPnTBPnnGninDNNnHOmiXPOMPEz50wT55xp4pwzTZxzhneV80A8TJxzpolzzjRxzhneDs+cM02cc4bvDi+cM02cc6aJc840cc6ZJj4QDxPnnGninDNNnHOGLf/COdPEOWeW+DhwzjRxzpldssaBc6aJc87s3eE4DMTDxDlnmjjnTBPnnGninDNNnHOGiS+cM+ycC+dME+ecaeKcM018IJ7dVRbOmSbOOdN3h5wzTZxzpolzzjDxlXOmiXPONHHOGTaglXOmiQ/Ew8Q5Z5o45wxb/so508Q5Z/rukHOGiR85Z5o450wT55xp4pwzfD9+HIiHiXPONHHOmSbOOcPOeeScaeKcM3x3ODhnmjjnTBPnnGninDN8dzgG4mHinDNNnHOmiXPOsAENzpkmzjnDd4cb50wT55xp4pwzfK+ycc408YF4mDjnTBPnnOH78Y1zpolzzvTdIecME985Z/jKuXPONHHOmSbOOdPEB+LZu8Odc6aJc8703SHnTH+Oc840cc4ZJn7inGninDN8r3LinGninDP9qTIQDxPnnGninDNNnHOmr5ycM02ccz4mvh+P11eyH08PiO/b4foz7ts/IPz51et+j8e6blcgH8H++uLt3us4n66xfPzn6fMX/zPLM5vtkyVP7pMlA++TJbf/OVleLlfUx8Oyfc1yyLJNlvaIH5Pl8XD8leUng7kf/K+XsW7r4fsvXs7nG4/L4fi1JTYULfmoxrbdWnI6f//FY79uRONy/Pzj/VEoE5FCPbVQFjCFemqhDHwK9a/r4XDT2sM6KoW6WBkV6qmFMnUq1L+uy3L7CZfj5Yu6XYyoWvK4JeZZLXnckqElWvKwJSZlLfnXdR23X7dZzw9exnI8X+90l3H4ekpxsT+r1JMrZYFWqb9Zqe2GY9m2veTu5mrte137bNva96r2bQdDuPb93fadbud62+Vcap/VXPte1z5rfNf2/SrUw+vj835NYTsY7hXqqYUaCqVQz/s1he3gOEChnloohwEK9br1wrmB9r2ufc4NtO9164VzA+17WfsW5wZN27ev6+1Fb9uDQn3/ex3bYt/XksctscNryTNvzBc7vEI9tVBDoRTqmYWywyvUU33MDq9QTy2Uaf3nFGpZrj/jcVm3R/PSS/6Gx7ZYyxXqqYUygCvUM3+XYbVpK9RTC2X+VqiX/XrCalbXvte1zwavfS/79YR1aJ/2vax91v2u7fs7/w7o+7/jvq0mey155iC2muwV6qmFMtkr1FMLZbJXqGcurEeTvUI9tVAme4V69Fd1t6NpXUset8QEriWPWzK0REue+eeUt6P9WaWeXCljtUq97JcJjpZt7Xtd+8zg2ve69tnMte9lv8oyDOza97r2WeObtu+Zfz9mWOO15HFLrPFa8swb8zEUSqGeWSizvUI9tVBGe4V6qo/Z4RXqqYUyrf8HCrXffrtx37cHhTrtVx6n06/yXXHbkpO4N+NpFLe1MIrb7Pb3bgbO+19w/wHRKvUY4ulwvYdYT8f1DsQBYh2i9eEJEN/UuJf1BvGT8tyHuN2+9XbZPn3nw92vvX7j7fzp+x7u2tHpphrH8/LJNcaf2bypvP6IbN7UA6fI5ny5Yj5e7mXzptL4E7LZ39Qwf0Q2b6qjPyKbN3XXH5HNmyrxj8hmyGbabN5U4H9ENnaBebOxCzw1m/327933sT7I5ny6Uj5/WseXcY3GLPCyaC775c+vvZy3v0Tz9WvHut1O+T+G0V9vsXvfeBuH6+S6jc9/refPc6Xd3vB+oZ8MGW8YuoXkDUM3vbxh6DadNwx9CP39QrdCvWHo5q03DN1u9oahW+TeMHSL3PuFfrbIvWHoFrk3DN0i94ahW+TeMPQh9PcL3SL3hqFb5N4wdIvcG4ZukXvD0C1y7xf6xSL3hqFb5N4wdIvcG4ZukXvD0IfQ3y90i9wbhm6Re8PQLXJvGLpF7g1Dt8i9Xej7wSL3hqFb5N4wdIvcG4ZukfsZoe+HK+axr4evOQ45tsjRbtYjR1NYjxytWz8kx2275Xi6k6PBqkeONqgWOS5mpR45Wop65Gj8aXG/uthzeuQ45NgiR3tOjxztOT3uc+w5PXK05/TI0Z7TIsfVntMjR3tOjxztOT1ytOf0yHHIsUWO9pweOdpzeuRoz+mRoz2nR472nBY5Hu05Lc6tjvacHjnac3rkaM/pkeOQY4v7HHtOjxztOT1ytOf0yNGe0yNHe06LHIc9p0eO9pweOdpzeuRoz+mR45BjixztOT1ytOf0yNGe0yNHe06Lc6thz2mR42bP6ZGjPadHjvacFvc5mz2nR45Dji1ytOf0yNGe0yNHe06PHO05PXK057TIcbfn9MjRntMjR3tOjxztOT1yHHJskaM9p0eO9pwW51a7PadHjvacHjnac1rkeLLntLjPOdlzeuRoz+mRoz2nR45Dji1ytOf0yNGe0yNHe06PHO05PXK057TI8WzP6ZGjPadHjvacHjnac3rkOOTY4dzqbM/pkaM9p0eO9pweOdpzetzn2HNa5Hix5/TI0Z7TI0d7To8c7Tk9chxybJGjPadHjvacHjnac3rkaM/pkaM9p0OOp4M9p0eO9pweOdpzOpxbfcQkxxY5Djm2yNGe0yNHe06P+xx7To8c7Tk9crTntMhxsef0yNGe0yNHe06PHO05PXIccmyRoz2nR472nB452nN65GjP6ZGjPadFjqs9p8W51WrP6ZGjPadHjvacHjkOOba4z7Hn9MjRntMjR3tOjxztOT1ytOe0yPFoz+mRoz2nR472nB452nN65Djk2CJHe06PHO05PXK05/TI0Z7T4tzqaM9pkeOw5/TI0Z7TI0d7Tov7nGHP6ZHjkGOLHO05PXK05/TI0Z7TI0d7To8c7TktctzsOT1ytOf0yNGe0yNHe06PHIccW+Roz+mRoz2nxbnVZs/pkaM9p0eO9pwWOe72nBb3Obs9p0eO9pweOdpzeuQ45NgiR3tOjxztOT1ytOf0yNGe0yNHe06LHE/2nB452nN65GjP6ZGjPadHjkOOHc6tTvacHjnac3rkaM/pkaM9p8d9jj2nRY5ne06PHO05PXK05/TI0Z7TI8chxxY52nN65GjP6ZGjPadHjvacHjnac1rkeLHn9MjRntMjR3tOi3Oriz2nR45Dji1ytOf0yNGe0+M+x57TI0d7To8c7Tkdcjwf7Dk9crTn9MjRntMjR3tOjxyHHFvkaM/pkaM9p0eO9pweOdpzeuRoz2mR42LP6XBudV7sOT1ytOf0yNGe0yPHIccW9zn2nB452nN65GjP6ZGjPadHjvacFjmu9pweOdpzeuRoz+mRoz2nR45Dji1ytOf0yNGe0yNHe06PHO05Lc6tVntOixyP9pweOdpzeuRoz2lxn3O05/TIccixRY72nB452nN65GjP6ZGjPadHjvacFjkOe06PHO05PXK05/TI0Z7TI8chxxY52nN65GjPaXFuNew5PXK05/TI0Z7TIsfNntPiPmez5/TI0Z7TI0d7To8chxxb5GjP6ZGjPadHjvacHjnac3rkaM9pkeNuz+mRoz2nR472nB452nN65Djk2OHcarfn9MjRntMjR3tOjxztOT3uc+w5LXI82XN65GjP6ZGjPadHjvacHjkOObbI0Z7TI0d7To8c7Tk9crTn9MjRntMix7M9p0eO9pweOdpzWpxbne05PXIccmyRoz2nR472nB73OfacHjnac3rkaM9pkePFntMjR3tOjxztOT1ytOf0yHHIsUWO9pweOdpzeuRoz+mRoz2nR472nA45Xg72nA7nVpeDPadHjvacHjnac3rkOOTY4j7HntMjR3tOjxztOT1ytOf0yNGe0yLHxZ7TI0d7To8c7Tk9crTn9MhxyLFFjvacHjnac3rkaM/pkaM9p8W51WLPaZHjas/pkaM9p0eO9pwW9zmrPadHjkOOLXK05/TI0Z7TI0d7To8c7Tk9crTntMjxaM/pkaM9p0eO9pweOdpzeuQ45NgiR3tOjxztOS3OrY72nB452nN65GjPaZHjsOe0uM8Z9pweOdpzeuRoz+mR45BjixztOT1ytOf0yNGe0yNHe06PHO05LXLc7Dk9crTn9MjRntMjR3tOjxyHHDucW232nB452nN65GjP6ZGjPafHfY49p0WOuz2nR472nB452nN65GjP6ZHjkGOLHO05PXK05/TI0Z7TI0d7To8c7TktcjzZc3rkaM/pkaM9p8W51cme0yPHIccWOdpzeuRoz+lxn2PP6ZGjPadHjvacFjme7Tk9crTn9MjRntMjR3tOjxyHHFvkaM/pkaM9p0eO9pweOdpzeuRoz2mR48We0+Lc6mLP6ZGjPadHjvacHjkOOba4z7Hn9MjRntMjR3tOjxztOT1ytOc0yHEcDvacHjnac3rkaM/pkaM9p0eOQ44tcrTn9MjRntMjR3tOjxztOQ3OrT5ytOe0yHGx5/TI0Z7TI0d7Tov7nMWe0yPH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",
            "brillig_names": [
                "get_contract_instance_internal",
                "decompose_hint",
                "lte_hint",
                "get_public_keys_and_partial_address",
                "random",
                "notify_created_note_oracle_wrapper",
                "get_key_validation_request",
                "field_less_than",
                "build_msg_block",
                "attach_len_to_msg_block",
                "build_msg_block",
                "emit_encrypted_note_log_oracle_wrapper",
                "directive_integer_quotient",
                "directive_invert"
            ]
        },
        {
            "name": "get_counter",
            "is_unconstrained": true,
            "custom_attributes": [],
            "abi": {
                "error_types": {},
                "parameters": [
                    {
                        "name": "owner",
                        "type": {
                            "fields": [
                                {
                                    "name": "inner",
                                    "type": {
                                        "kind": "field"
                                    }
                                }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        },
                        "visibility": "private"
                    }
                ],
                "return_type": {
                    "abi_type": {
                        "kind": "field"
                    },
                    "visibility": "public"
                }
            },
            "bytecode": "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",
            "debug_symbols": "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",
            "brillig_names": [
                "get_counter"
            ]
        }
    ],
    "outputs": {
        "globals": {
            "notes": [
                {
                    "fields": [
                        {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000003de78269"
                        },
                        {
                            "kind": "string",
                            "value": "ValueNote"
                        },
                        {
                            "fields": [
                                {
                                    "name": "value",
                                    "value": {
                                        "fields": [
                                            {
                                                "name": "index",
                                                "value": {
                                                    "kind": "integer",
                                                    "sign": false,
                                                    "value": "0000000000000000000000000000000000000000000000000000000000000000"
                                                }
                                            },
                                            {
                                                "name": "nullable",
                                                "value": {
                                                    "kind": "boolean",
                                                    "value": false
                                                }
                                            }
                                        ],
                                        "kind": "struct"
                                    }
                                },
                                {
                                    "name": "owner",
                                    "value": {
                                        "fields": [
                                            {
                                                "name": "index",
                                                "value": {
                                                    "kind": "integer",
                                                    "sign": false,
                                                    "value": "0000000000000000000000000000000000000000000000000000000000000001"
                                                }
                                            },
                                            {
                                                "name": "nullable",
                                                "value": {
                                                    "kind": "boolean",
                                                    "value": false
                                                }
                                            }
                                        ],
                                        "kind": "struct"
                                    }
                                },
                                {
                                    "name": "randomness",
                                    "value": {
                                        "fields": [
                                            {
                                                "name": "index",
                                                "value": {
                                                    "kind": "integer",
                                                    "sign": false,
                                                    "value": "0000000000000000000000000000000000000000000000000000000000000002"
                                                }
                                            },
                                            {
                                                "name": "nullable",
                                                "value": {
                                                    "kind": "boolean",
                                                    "value": false
                                                }
                                            }
                                        ],
                                        "kind": "struct"
                                    }
                                }
                            ],
                            "kind": "struct"
                        }
                    ],
                    "kind": "tuple"
                }
            ],
            "storage": [
                {
                    "fields": [
                        {
                            "name": "contract_name",
                            "value": {
                                "kind": "string",
                                "value": "Counter"
                            }
                        },
                        {
                            "name": "fields",
                            "value": {
                                "fields": [
                                    {
                                        "name": "counters",
                                        "value": {
                                            "fields": [
                                                {
                                                    "name": "slot",
                                                    "value": {
                                                        "kind": "integer",
                                                        "sign": false,
                                                        "value": "0000000000000000000000000000000000000000000000000000000000000001"
                                                    }
                                                }
                                            ],
                                            "kind": "struct"
                                        }
                                    }
                                ],
                                "kind": "struct"
                            }
                        }
                    ],
                    "kind": "struct"
                }
            ]
        },
        "structs": {
            "functions": [
                {
                    "fields": [
                        {
                            "name": "parameters",
                            "type": {
                                "fields": [
                                    {
                                        "name": "headstart",
                                        "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 64
                                        }
                                    },
                                    {
                                        "name": "owner",
                                        "type": {
                                            "fields": [
                                                {
                                                    "name": "inner",
                                                    "type": {
                                                        "kind": "field"
                                                    }
                                                }
                                            ],
                                            "kind": "struct",
                                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                        }
                                    },
                                    {
                                        "name": "outgoing_viewer",
                                        "type": {
                                            "fields": [
                                                {
                                                    "name": "inner",
                                                    "type": {
                                                        "kind": "field"
                                                    }
                                                }
                                            ],
                                            "kind": "struct",
                                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                        }
                                    }
                                ],
                                "kind": "struct",
                                "path": "Counter::initialize_parameters"
                            }
                        }
                    ],
                    "kind": "struct",
                    "path": "Counter::initialize_abi"
                },
                {
                    "fields": [
                        {
                            "name": "parameters",
                            "type": {
                                "fields": [
                                    {
                                        "name": "owner",
                                        "type": {
                                            "fields": [
                                                {
                                                    "name": "inner",
                                                    "type": {
                                                        "kind": "field"
                                                    }
                                                }
                                            ],
                                            "kind": "struct",
                                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                        }
                                    },
                                    {
                                        "name": "outgoing_viewer",
                                        "type": {
                                            "fields": [
                                                {
                                                    "name": "inner",
                                                    "type": {
                                                        "kind": "field"
                                                    }
                                                }
                                            ],
                                            "kind": "struct",
                                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                        }
                                    }
                                ],
                                "kind": "struct",
                                "path": "Counter::increment_parameters"
                            }
                        }
                    ],
                    "kind": "struct",
                    "path": "Counter::increment_abi"
                }
            ]
        }
    },
    "file_map": {
        "101": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
            "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n        compute_unique_note_hash,\n    },\n    utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
        },
        "106": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr",
            "source": "use crate::utils::point::point_to_bytes;\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, point::Point, scalar::Scalar, utils::arr_copy_slice,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, hash::sha256};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator =\n        arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"
        },
        "108": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
            "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n"
        },
        "112": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/hash.nr",
            "source": "use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
        },
        "113": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/initializer.nr",
            "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
        },
        "125": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
            "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    let (member, exists) = get_contract_instance_deployer_internal_avm(address);\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    let (member, exists) = get_contract_instance_class_id_internal_avm(address);\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    let (member, exists) = get_contract_instance_initialization_hash_internal_avm(address);\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
        },
        "130": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
            "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
        },
        "131": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
            "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
        },
        "132": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
            "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n    utils::arr_copy_slice,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used for tagging with this secret.\n/// For this to work, PXE must know the ivpsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_app_tagging_secret(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_app_tagging_secret_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getAppTaggingSecret)]\nunconstrained fn get_app_tagging_secret_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Returns the tagging secrets for a given recipient and all the senders in PXE's address book,\n// siloed for the current contract address.\n/// Includes the last known index used for tagging with this secret.\n/// For this to work, PXE must know the ivsk_m of the recipient.\npub unconstrained fn get_app_tagging_secrets_for_senders(\n    recipient: AztecAddress,\n) -> [IndexedTaggingSecret] {\n    let results = get_app_tagging_secrets_for_senders_oracle(recipient);\n    let mut indexed_tagging_secrets = &[];\n    for i in 0..results.len() {\n        if i % 2 != 0 {\n            continue;\n        }\n        indexed_tagging_secrets = indexed_tagging_secrets.push_back(\n            IndexedTaggingSecret::deserialize([results[i], results[i + 1]]),\n        );\n    }\n    indexed_tagging_secrets\n}\n\n#[oracle(getAppTaggingSecretsForSenders)]\nunconstrained fn get_app_tagging_secrets_for_senders_oracle(_recipient: AztecAddress) -> [Field] {}\n"
        },
        "135": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
            "source": "use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
        },
        "136": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
            "source": "use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(\n            contract_address,\n            randomness,\n            encrypted_event,\n            counter,\n        )\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32,\n) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\npub unconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {}\n"
        },
        "140": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
            "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
        },
        "144": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
            "source": "use dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use crate::utils::point::point_to_bytes;\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"
        },
        "169": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr",
            "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash_with_separator, point::Point, public_keys::OvpkM, scalar::Scalar,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    field::bn254::decompose, hash::from_field_unsafe as fr_to_fq_unsafe,\n};\n\nuse crate::{\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::point_to_symmetric_key::point_to_symmetric_key, oracle::random::random,\n    utils::point::point_to_bytes,\n};\nuse protocol_types::public_keys::AddressPoint;\n\nfn compute_private_log_payload<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n    include_public_values_prefix: bool,\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] =\n        header.compute_ciphertext(eph_sk, recipient.to_address_point());\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext =\n        compute_incoming_body_ciphertext(plaintext, eph_sk, recipient.to_address_point());\n    let outgoing_body_ciphertext: [u8; 144] =\n        compute_outgoing_body_ciphertext(recipient, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    // If we include the prefix for number of public values, we need to add 1 byte to the offset\n    let mut offset = if include_public_values_prefix { 1 } else { 0 };\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n    offset += 64;\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[offset + i] = eph_pk_bytes[i];\n    }\n\n    offset += 32;\n    for i in 0..48 {\n        encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[offset + 48 + i] = outgoing_header_ciphertext[i];\n    }\n\n    offset += 48 * 2;\n    for i in 0..144 {\n        encrypted_bytes[offset + i] = outgoing_body_ciphertext[i];\n    }\n\n    offset += 144;\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - offset;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // empty_prefix (1 byte)\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    address_point: AddressPoint,\n) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, address_point.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's address point --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point,\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_address_point =\n        point_to_bytes(recipient.to_address_point().to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_address_point[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field,\n    )\n        .to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext,\n        compute_private_log_payload,\n    };\n    use dep::protocol_types::{\n        address::AztecAddress, point::Point, public_keys::OvpkM, scalar::Scalar,\n    };\n    use protocol_types::public_keys::AddressPoint;\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n        let ovsk_app = 0x191ac5e29bbc8f80f29ed06b75eaf30c036ed7952d844833860c527077c8c3b4;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x07f696b8b233de2c1935e43c793399586f532da5ff7c0356636a75acb862e964,\n                y: 0x156e8a3e42bfca3663936ba98c7fd26386a14657c23b5f5146f1a94b6c465154,\n                is_infinite: false,\n            },\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let log: [u8; 448] = compute_private_log_payload(\n            contract_address,\n            ovsk_app,\n            ovpk_m,\n            recipient,\n            plaintext,\n            false,\n        );\n\n        // The following value was generated by `encrypted_log_payload.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235,\n            86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 5, 119,\n            121, 10, 234, 188, 194, 216, 30, 200, 208, 201, 158, 127, 93, 43, 242, 241, 69, 32, 37,\n            220, 119, 122, 23, 132, 4, 248, 81, 217, 61, 232, 24, 146, 63, 133, 24, 120, 113, 217,\n            155, 223, 149, 214, 149, 239, 240, 169, 224, 155, 161, 81, 83, 252, 155, 77, 34, 75,\n            110, 30, 113, 223, 189, 202, 171, 6, 192, 157, 91, 60, 116, 155, 254, 190, 28, 4, 7,\n            236, 205, 4, 245, 27, 187, 89, 20, 38, 128, 200, 160, 145, 185, 127, 198, 203, 207, 97,\n            246, 194, 175, 155, 142, 188, 143, 120, 83, 122, 178, 63, 208, 197, 232, 24, 228, 212,\n            45, 69, 157, 38, 90, 219, 119, 194, 239, 130, 155, 246, 143, 135, 242, 196, 123, 71,\n            139, 181, 122, 231, 228, 26, 7, 100, 63, 101, 195, 83, 8, 61, 85, 123, 148, 227, 29,\n            164, 162, 161, 49, 39, 73, 141, 46, 179, 240, 52, 109, 165, 238, 210, 233, 188, 36, 90,\n            175, 2, 42, 149, 78, 208, 176, 145, 50, 180, 152, 245, 55, 112, 40, 153, 180, 78, 54,\n            102, 119, 98, 56, 235, 246, 51, 179, 86, 45, 127, 18, 77, 187, 168, 41, 24, 232, 113,\n            149, 138, 148, 33, 143, 215, 150, 188, 105, 131, 254, 236, 199, 206, 56, 44, 130, 134,\n            29, 99, 254, 69, 153, 146, 68, 234, 148, 148, 178, 38, 221, 182, 148, 178, 100, 13, 206,\n            0, 91, 71, 58, 207, 26, 227, 190, 21, 143, 85, 138, 209, 202, 34, 142, 159, 121, 61, 9,\n            57, 2, 48, 162, 89, 126, 14, 83, 173, 40, 247, 170, 154, 112, 12, 204, 48, 38, 7, 173,\n            108, 38, 234, 20, 16, 115, 91, 106, 140, 121, 63, 99, 23, 247, 0, 148, 9, 163, 145, 43,\n            21, 238, 47, 40, 204, 241, 124, 246, 201, 75, 114, 3, 1, 229, 197, 130, 109, 227, 158,\n            133, 188, 125, 179, 220, 51, 170, 121, 175, 202, 243, 37, 103, 13, 27, 53, 157, 8, 177,\n            11, 208, 120, 64, 211, 148, 201, 240, 56,\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let address_point = AddressPoint {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `address_point` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, address_point);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb,\n        };\n\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b,\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let ciphertext =\n            compute_outgoing_body_ciphertext(recipient, sender_ovsk_app, eph_sk, eph_pk);\n\n        // The following value was generated by `encrypted_log_payload.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238,\n            50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248,\n            43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31,\n            211, 190, 124, 121, 79, 92, 238, 182, 194, 225, 34, 71, 67, 116, 27, 231, 68, 161, 147,\n            94, 53, 195, 83, 237, 172, 52, 173, 229, 26, 234, 107, 43, 82, 68, 16, 105, 37, 125,\n            117, 86, 133, 50, 21, 92, 74, 229, 105, 141, 83, 229, 255, 251, 21, 61, 234, 61, 168,\n            221, 106, 231, 8, 73, 208, 60, 251, 46, 251, 228, 148, 144, 187, 195, 38, 18, 223, 153,\n            8, 121, 178, 84, 237, 148, 254, 219, 59, 62,\n        ];\n\n        assert_eq(outgoing_body_ciphertext_from_typescript, ciphertext);\n    }\n}\n"
        },
        "17": {
            "path": "std/ec/mod.nr",
            "source": "// Elliptic curve implementation\n// Overview\n// ========\n// The following three elliptic curve representations are admissible:\npub mod tecurve; // Twisted Edwards curves\npub mod swcurve; // Elliptic curves in Short Weierstrass form\npub mod montcurve; // Montgomery curves\npub mod consts; // Commonly used curve presets\n//\n// Note that Twisted Edwards and Montgomery curves are (birationally) equivalent, so that\n// they may be freely converted between one another, whereas Short Weierstrass curves are\n// more general. Diagramatically:\n//\n// tecurve == montcurve `subset` swcurve\n//\n// Each module is further divided into two submodules, 'affine' and 'curvegroup', depending\n// on the preferred coordinate representation. Affine coordinates are none other than the usual\n// two-dimensional Cartesian coordinates used in the definitions of these curves, whereas\n// 'CurveGroup' coordinates (terminology borrowed from Arkworks, whose conventions we try\n// to follow) are special coordinate systems with respect to which the group operations may be\n// implemented more efficiently, usually by means of an appropriate choice of projective coordinates.\n//\n// In each of these submodules, there is a Point struct and a Curve struct, the former\n// representing a point in the coordinate system and the latter a curve configuration.\n//\n// Points\n// ======\n// Points may be instantiated using the associated function `new`, which takes coordinates\n// as its arguments. For instance,\n//\n// `let p = swcurve::Point::new(1,1);`\n//\n// The additive identity may be constructed by a call to the associated function `zero` of no\n// arguments:\n//\n// `let zero = swcurve::Point::zero();`\n//\n// Points may be tested for equality by calling the method `eq`:\n//\n// `let pred = p.eq(zero);`\n//\n// There is also the method `is_zero` to explicitly check whether a point is the additive identity:\n//\n// `constrain pred == p.is_zero();`\n//\n// Points may be negated by calling the `negate` method and converted to CurveGroup (or affine)\n// coordinates by calling the `into_group` (resp. `into_affine`) method on them. Finally,\n// Points may be freely mapped between their respective Twisted Edwards and Montgomery\n// representations by calling the `into_montcurve` or `into_tecurve` methods. For mappings\n// between Twisted Edwards/Montgomery curves and Short Weierstrass curves, see the Curve section\n// below, as the underlying mappings are those of curves rather than ambient spaces.\n// As a rule, Points in affine (or CurveGroup) coordinates are mapped to Points in affine\n// (resp. CurveGroup) coordinates.\n//\n// Curves\n// ======\n// A curve configuration (Curve) is completely determined by the Field coefficients of its defining\n// equation (a and b in the case of swcurve, a and d in the case of tecurve, and j and k in\n// the case of montcurve) together with a generator (`gen`) in the corresponding coordinate system.\n// For example, the Baby Jubjub curve configuration as defined in ERC-2494 may be instantiated as a Twisted\n// Edwards curve in affine coordinates as follows:\n//\n// `let bjj_affine = tecurve::Curve::new(168700, 168696, tecurve::Point::new(995203441582195749578291179787384436505546430278305826713579947235728471134,5472060717959818805561601436314318772137091100104008585924551046643952123905));`\n//\n// The `contains` method may be used to check whether a Point lies on a given curve:\n//\n// `constrain bjj_affine.contains(tecurve::Point::zero());`\n//\n// The elliptic curve group's addition operation is exposed as the `add` method, e.g.\n//\n// `let p = bjj_affine.add(bjj_affine.gen, bjj_affine.gen);`\n//\n// subtraction as the `subtract` method, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.subtract(bjj_affine.gen, bjj_affine.gen));`\n//\n// scalar multiplication as the `mul` method, where the scalar is assumed to be a Field* element, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.mul(2, tecurve::Point::zero());`\n//\n// There is a scalar multiplication method (`bit_mul`) provided where the scalar input is expected to be\n// an array of bits (little-endian convention), as well as a multi-scalar multiplication method** (`msm`)\n// which takes an array of Field elements and an array of elliptic curve points as arguments, both assumed\n// to be of the same length.\n//\n// Curve configurations may be converted between different coordinate representations by calling the `into_group`\n// and `into_affine` methods on them, e.g.\n//\n// `let bjj_curvegroup = bjj_affine.into_group();`\n//\n// Curve configurations may also be converted between different curve representations by calling the `into_swcurve`,\n// `into_montcurve` and `into_tecurve` methods subject to the relation between the curve representations mentioned\n// above. Note that it is possible to map Points from a Twisted Edwards/Montgomery curve to the corresponding\n// Short Weierstrass representation and back, and the methods to do so are exposed as `map_into_swcurve` and\n// `map_from_swcurve`, which each take one argument, the point to be mapped.\n//\n// Curve maps\n// ==========\n// There are a few different ways of mapping Field elements to elliptic curves. Here we provide the simplified\n// Shallue-van de Woestijne-Ulas and Elligator 2 methods, the former being applicable to all curve types\n// provided above subject to the constraint that the coefficients of the corresponding Short Weierstrass curve satisfies\n// a*b != 0 and the latter being applicable to Montgomery and Twisted Edwards curves subject to the constraint that\n// the coefficients of the corresponding Montgomery curve satisfy j*k != 0 and (j^2 - 4)/k^2 is non-square.\n//\n// The simplified Shallue-van de Woestijne-Ulas method is exposed as the method `swu_map` on the Curve configuration and\n// depends on two parameters, a Field element z != -1 for which g(x) - z is irreducible over Field and g(b/(z*a)) is\n// square, where g(x) = x^3 + a*x + b is the right-hand side of the defining equation of the corresponding Short\n// Weierstrass curve, and a Field element u to be mapped onto the curve. For example, in the case of bjj_affine above,\n// it may be determined using the scripts provided at <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve> that z = 5.\n//\n// The Elligator 2 method is exposed as the method `elligator2_map` on the Curve configurations of Montgomery and\n// Twisted Edwards curves. Like the simplified SWU method above, it depends on a certain non-square element of Field,\n// but this element need not satisfy any further conditions, so it is included as the (Field-dependent) constant\n//`ZETA` below. Thus, the `elligator2_map` method depends only on one parameter, the Field element to be mapped onto\n// the curve.\n//\n// For details on all of the above in the context of hashing to elliptic curves, see <https://datatracker.ietf.org/doc/id/draft-irtf-cfrg-hash-to-curve-06.html>.\n//\n//\n// *TODO: Replace Field with Bigint.\n// **TODO: Support arrays of structs to make this work.\n// Field-dependent constant ZETA = a non-square element of Field\n// Required for Elligator 2 map\n// TODO: Replace with built-in constant.\nglobal ZETA = 5;\n// Field-dependent constants for Tonelli-Shanks algorithm (see sqrt function below)\n// TODO: Possibly make this built-in.\nglobal C1 = 28;\nglobal C3 = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5 = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n// Higher-order version of scalar multiplication\n// TODO: Make this work so that the submodules' bit_mul may be defined in terms of it.\n//fn bit_mul<T,N>(add: fn(T,T) -> T, e: T, bits: [u1; N], p: T) -> T {\n//    let mut out = e;\n//    let n = bits.len();\n//\n//    for i in 0..n {\n//        out = add(\n//            add(out, out),\n//            if(bits[n - i - 1] == 0) {e} else {p});\n//    }\n//\n//    out\n//}\n// TODO: Make this built-in.\npub fn safe_inverse(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        1 / x\n    }\n}\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\npub fn is_square(x: Field) -> bool {\n    let v = pow(x, 0 - 1 / 2);\n\n    v * (v - 1) == 0\n}\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n"
        },
        "170": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr",
            "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    point::Point,\n    public_keys::{IvpkM, PublicKeys, ToPoint},\n    scalar::Scalar,\n};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"
        },
        "171": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr",
            "source": "use crate::{\n    context::PrivateContext,\n    encrypted_logs::payload::compute_private_log_payload,\n    keys::getters::get_ovsk_app,\n    note::{note_emission::NoteEmission, note_interface::NoteInterface},\n};\nuse dep::protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, hash::sha256_to_field, public_keys::OvpkM,\n};\n\n/// Computes private note log payload and a log hash\nfn compute_payload_and_hash<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 417 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n\n    // For note logs we always include public values prefix\n    let encrypted_log: [u8; 417 + N * 32] =\n        compute_private_log_payload(contract_address, ovsk_app, ovpk, recipient, plaintext, true);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_payload_and_hash_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 417 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_payload_and_hash(context, note, ovsk_app, ovpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let ovsk_app: Field = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) =\n            compute_payload_and_hash(*context, e.note, ovsk_app, ovpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) =\n            unsafe { compute_payload_and_hash_unconstrained(*context, e.note, ovpk, recipient) };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n"
        },
        "173": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
            "source": "use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        arguments,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        header::get_header_at,\n        key_validation_request::get_key_validation_request,\n        logs::{emit_encrypted_event_log, emit_encrypted_note_log},\n        returns::pack_returns,\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log_hash::{EncryptedLogHash, LogHash, NoteLogHash},\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_ENCRYPTED_LOGS_PER_CALL, MAX_KEY_VALIDATION_REQUESTS_PER_CALL,\n        MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    },\n    header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
        },
        "174": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
            "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"
        },
        "214": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
            "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
        },
        "24": {
            "path": "std/embedded_curve_ops.nr",
            "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
        },
        "249": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
            "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
        },
        "25": {
            "path": "std/field/bn254.nr",
            "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
        },
        "26": {
            "path": "std/field/mod.nr",
            "source": "pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
        },
        "263": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
            "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
        },
        "265": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
            "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::default::Default;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
        },
        "270": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
            "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedEncryptedLogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__VK,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    proof::verification_key::VerificationKey,\n    traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
        },
        "282": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr",
            "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"
        },
        "29": {
            "path": "std/hash/mod.nr",
            "source": "pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
        },
        "3": {
            "path": "std/array/mod.nr",
            "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"
        },
        "304": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
            "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"
        },
        "321": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
            "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
        },
        "322": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
            "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n    utils,\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    ec::{pow, sqrt},\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
        },
        "323": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
            "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
        },
        "326": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
            "source": "use crate::{\n    address::{\n        aztec_address::AztecAddress, partial_address::PartialAddress,\n        public_keys_hash::PublicKeysHash,\n    },\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    salt: Field,\n    deployer: AztecAddress,\n    contract_class_id: ContractClassId,\n    initialization_hash: Field,\n    public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"
        },
        "331": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/easy-private-state/src/easy_private_uint.nr",
            "source": "use dep::aztec::{\n    context::PrivateContext, encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n    keys::getters::get_public_keys, note::note_getter_options::NoteGetterOptions,\n    protocol_types::address::AztecAddress, state_vars::PrivateSet,\n};\nuse dep::value_note::{filter::filter_notes_min_sum, value_note::ValueNote};\n\npub struct EasyPrivateUint<Context> {\n    context: Context,\n    set: PrivateSet<ValueNote, Context>,\n    storage_slot: Field,\n}\n\n// Holds a note that can act similarly to an int.\nimpl<Context> EasyPrivateUint<Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = PrivateSet::new(context, storage_slot);\n        EasyPrivateUint { context, set, storage_slot }\n    }\n}\n\nimpl EasyPrivateUint<&mut PrivateContext> {\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let outgoing_viewer_keys = get_public_keys(outgoing_viewer);\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner);\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note).emit(encode_and_encrypt_note(\n            self.context,\n            outgoing_viewer_keys.ovpk_m,\n            owner,\n        ));\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let outgoing_viewer_keys = get_public_keys(outgoing_viewer);\n\n        // docs:start:pop_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let notes = self.set.pop_notes(options);\n        // docs:end:pop_notes\n        let mut minuend: u64 = 0;\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n\n                minuend += note.value as u64;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner);\n        self.set.insert(&mut result_note).emit(encode_and_encrypt_note(\n            self.context,\n            outgoing_viewer_keys.ovpk_m,\n            owner,\n        ));\n    }\n}\n"
        },
        "333": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/value-note/src/balance_utils.nr",
            "source": "use crate::value_note::ValueNote;\nuse dep::aztec::{\n    context::UnconstrainedContext, note::note_viewer_options::NoteViewerOptions,\n    state_vars::PrivateSet,\n};\n\npub unconstrained fn get_balance(set: PrivateSet<ValueNote, UnconstrainedContext>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\npub unconstrained fn get_balance_with_offset(\n    set: PrivateSet<ValueNote, UnconstrainedContext>,\n    offset: u32,\n) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let mut options = NoteViewerOptions::new();\n    let notes = set.view_notes(options.set_offset(offset));\n    // docs:end:view_notes\n    for i in 0..options.limit {\n        if i < notes.len() {\n            balance += notes.get_unchecked(i).value;\n        }\n    }\n\n    if (notes.len() == options.limit) {\n        balance += get_balance_with_offset(set, offset + options.limit);\n    }\n\n    balance\n}\n"
        },
        "337": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/value-note/src/value_note.nr",
            "source": "use dep::aztec::{\n    context::PrivateContext,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::note,\n    note::{\n        note_header::NoteHeader, note_interface::NullifiableNote,\n        utils::compute_note_hash_for_nullify,\n    },\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator, traits::Serialize,\n    },\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n"
        },
        "34": {
            "path": "std/hash/poseidon2.nr",
            "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
        },
        "35": {
            "path": "std/hash/sha256.nr",
            "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8 = 256;\nglobal TWO_POW_16 = TWO_POW_8 * 256;\nglobal TWO_POW_24 = TWO_POW_16 * 256;\nglobal TWO_POW_32 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n"
        },
        "59": {
            "path": "std/panic.nr",
            "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
        },
        "6": {
            "path": "std/cmp.nr",
            "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
        },
        "7": {
            "path": "std/collections/bounded_vec.nr",
            "source": "use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"
        },
        "70": {
            "path": "/home/kimani/aztec/aztec-private-counter/contracts/counter/src/main.nr",
            "source": "use dep::aztec::macros::aztec;\n\n#[aztec]\ncontract Counter {\n    use aztec::macros::{functions::{initializer, private}, storage::storage};\n    use aztec::prelude::{AztecAddress, Map};\n    use easy_private_state::EasyPrivateUint;\n    use value_note::{balance_utils, value_note::ValueNote};\n\n    #[storage]\n    struct Storage<Context> {\n        counters: Map<AztecAddress, EasyPrivateUint<Context>, Context>,\n    }\n\n    #[initializer]\n    #[private]\n    // We can name our initializer anything we want as long as it's marked as aztec(initializer)\n    fn initialize(headstart: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let counters = storage.counters;\n        counters.at(owner).add(headstart, owner, outgoing_viewer);\n    }\n\n    #[private]\n    fn increment(owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        unsafe {\n            dep::aztec::oracle::debug_log::debug_log_format(\n                \"Incrementing counter for owner {0}\",\n                [owner.to_field()],\n            );\n        }\n        let counters = storage.counters;\n        counters.at(owner).add(1, owner, outgoing_viewer);\n    }\n\n    unconstrained fn get_counter(owner: AztecAddress) -> pub Field {\n        let counters = storage.counters;\n        balance_utils::get_balance(counters.at(owner).set)\n    }\n\n}\n"
        },
        "85": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
            "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    storage::map::derive_storage_slot_in_map,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<T, N> for Map<K, T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
        },
        "88": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
            "source": "use crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest,\n    constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::{Deserialize, Serialize},\n};\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PrivateSet<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
        },
        "91": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
            "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
        },
        "92": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
            "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\nuse dep::protocol_types::constants::{\n    GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note = unsafe { get_note_internal(storage_slot) };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
        },
        "94": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
            "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_header::NoteHeader,\n    note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_nullify_internal, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
        },
        "96": {
            "path": "/home/kimani/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.61.0/noir-projects/aztec-nr/aztec/src/note/note_viewer_options.nr",
            "source": "use crate::note::constants::MAX_NOTES_PER_PAGE;\nuse crate::note::note_getter_options::{NoteStatus, PropertySelector, Select, Sort};\nuse crate::note::note_interface::NoteInterface;\nuse dep::protocol_types::traits::ToField;\nuse std::option::Option;\n\n// docs:start:NoteViewerOptions\npub struct NoteViewerOptions<Note, let N: u32> {\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n    limit: u32,\n    offset: u32,\n    status: u8,\n}\n// docs:end:NoteViewerOptions\n\nimpl<Note, let N: u32> NoteViewerOptions<Note, N> {\n    pub fn new() -> NoteViewerOptions<Note, N>\n    where\n        Note: NoteInterface<N>,\n    {\n        NoteViewerOptions {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTES_PER_PAGE as u32,\n            offset: 0,\n            status: NoteStatus.ACTIVE,\n        }\n    }\n\n    // This method adds a `Select` criterion to the options.\n    // It takes a field_index indicating which field to select,\n    // a value representing the specific value to match in that field, and\n    // a comparator (For possible values of comparators, please see the Comparator enum from note_getter_options)\n    pub fn select<T>(\n        &mut self,\n        property_selector: PropertySelector,\n        comparator: u8,\n        value: T,\n    ) -> Self\n    where\n        T: ToField,\n    {\n        self.selects.push(Option::some(Select::new(property_selector, comparator, value.to_field())));\n        *self\n    }\n\n    pub fn sort(&mut self, property_selector: PropertySelector, order: u8) -> Self {\n        self.sorts.push(Option::some(Sort::new(property_selector, order)));\n        *self\n    }\n\n    pub fn set_limit(&mut self, limit: u32) -> Self {\n        assert(limit <= MAX_NOTES_PER_PAGE as u32);\n        // By requesting that the limit is a constant, we guarantee that it will be possible to loop over it, reducing\n        // gate counts when a limit has been set.\n        if !dep::std::runtime::is_unconstrained() {\n            assert_constant(limit);\n        }\n        self.limit = limit;\n        *self\n    }\n\n    pub fn set_offset(&mut self, offset: u32) -> Self {\n        self.offset = offset;\n        *self\n    }\n\n    // This method sets the status value, which determines whether to retrieve active or nullified notes.\n    pub fn set_status(&mut self, status: u8) -> Self {\n        self.status = status;\n        *self\n    }\n}\n"
        }
    }
}